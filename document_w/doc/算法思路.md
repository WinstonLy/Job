### 1. 反转链表

定义一个函数，输入链表的头节点，反转该链表并输出反转后链表的头节点

如 ：1->2->3->4->5->NULL    输出：5->4->3->2->1->NULL

**解法一：迭代**

在遍历列表时，temp保存当前节点（pre）的下一个节点信息，并将当前节点的next指针改为指向前一个节点，需要事先存储前一个节点的信息cur（cur初始化为NULL），每一次反转之后需要将前一个节点cur指向当前节点pre，当前节点指向下一个节点temp

**解法二：递归**

1. 使用递归函数，一直递归到最后一个节点，该节点就是反转之后的头节点，记作 ret 
2. 每次函数再返回的过程中让当前节点的下一个节点的next指向当前节点
3. 同时让当前节点的 next 指向 NULL
4. 完成递归后，链表反转完成

### 2. 最大子序和

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```shell
输入：[-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组[4,-1,2,1]的和最带，为6
```

**动态规划**

用 a<sub>i</sub> 代表 nums[i]，用 f(i) 代表第 i 个数据结尾的连续数组的最大和，那么要求的答案就是 最大的 f(i)

求出每一个位置的 f(i), 并判断 f(i-1) + a<sub>i</sub> 和 f(i-1) 的大小，当 f(i-1) < 0 时，对 a<sub>i</sub> 无增益，产生新的子数组开始 a<sub>i</sub>，

```shell
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int pre = 0, maxAns = nums[0];
        for (const auto &x: nums) {
            pre = max(pre + x, x);
            maxAns = max(maxAns, pre);
        }
        return maxAns;
    }
};
```

### 3. 字符串转换整数 (atoi)

题目链接：[字符串转换整数](https://leetcode-cn.com/problems/string-to-integer-atoi/)

**有限状态机**(DFA)

程序在每个时刻有一个状态 s，每次从序列中输入一个字符 c，根据不同的 c 转移到下一个状态 s。

下面是建立起来的状态表

|           | ' '   | +/-    | number    | other |
| --------- | ----- | ------ | --------- | ----- |
| start     | start | signed | in_number | end   |
| signed    | end   | end    | in_number | end   |
| in_number | end   | end    | in_number | end   |
| end       | end   | end    | end       | end   |

然后将这个表实现在代码中即可

- 先建立状态表
- 获取对应字符的下一状态
- 转换字符

**位运算求最大值**

题目主要注意三个方面：

- 转化过程防止越界
- 求 int 型的最大最小值 (((1<<30)-1)<<1)+1
- 各种边界条件判断

先判断到第一个非空字符，如果字符串为空或者不是 + - 0~9 中的字符，return 0

然后在判断符号标志，最后转换字符

### 4. KMP算法（字符串匹配）

问题：有一个文本串 S，和一个模式串 P，如何查找 P 在 S 中的位置

1. 暴力匹配算法

    假设文本串 S 匹配到 i 位置，模式串 P 匹配到 j 位置：

    - 如果当前字符匹配成功，(S[i] == S[j]) ，则 ++i，++j，继续匹配下一个字符
    - 如匹配失败(S[i] != S[j])，则 i = i - (j - 1), j = 0;，相当于每次匹配失败，i 回溯到这次比较的开始位置的下一位置，j 被置为 0

    ```shell
    int ViolentMatch(string s, string p)
    {
    	int i = 0;
    	int j = 0;
    	int sLen = s.size();
    	int pLen = p.size();
    	
    	while(i < sLen && j < pLen)
    	{
    		// 如果当前字符匹配成功（即S[i] == P[j]），则i++，j++ 
    		if(s[i] == s[j])
    		{
    			++i;
    			++j;
    		}
    		else
    		{
    			// 如果失配（即S[i]! = P[j]），令i = i - (j - 1)，j = 0   
    			i = i - j + 1;
    			j = 0;
    		}
    	}
    	// 匹配成功，返回模式串p在文本串s中的位置，否则返回-1
    	if(j == pLen)
    		return i - j;
    	else
    		return -1;
    }
    ```

    暴力匹配的方法实现简单，但是效率低，因为进行了很多重复性的比较，该算法复杂度为：O(n + m)

2. KMP 字符串匹配算法

    > 字符串的真前缀和真后缀
    >
    > 字符串：abcdac
    >
    > 真前缀：a、ab、abc、abcd、abcda
    >
    > 真后缀：cadcb、cadc、cad、ca、c

KMP算法的精妙之处在于：能够知道在匹配失败之后，有多少字符是不需要进行匹配可以直接跳过的

首先求解一个next[n]数组，这个数组的值表示了字符串下标 n 位置的最大真前后缀，当两者不匹配时，通过next[n]跳转到需要比较的模式串的相应下标处。

**next数组的求法**：

k表示后缀，j 表示前缀，后缀一直保持在递增的顺序，前缀则根据匹配的结果来变化，当 p[j] == p[k] 时，++i，++j，同时迭代next数组（next[k] = j），当 p[j] != p[k] 时，令后缀回到最初的状态，j = next[j]。

```shell
void getNext(string s, int next[])
{
	int sLen = s.size();
	next[0] = -1;
	int k = 0;
	int j = -1;
	
	while(k < pLen -1)
	{
		if(j == -1 || p[k] == p[j])
		{
			++k;
			++j;
			next[k] = j;
		}
		else
		{
			j = next[j];
		}
	}
}
```

得到了next[n] 数组，在进行比较文本串和模式串的时候，当 s[i] != p[j] 时，j = p[ next[j] ]；

```shell
int KMP(string s, string p, int next[])
{
	// 获取 next[n] 数组
	GetNext(p, next);
	
	int sLen = s.size();
	int pLen = p.size();
	int i = 0;
	int j = 0;
	while(i < sLen && j < pLen)
	{
		if(p[i] == p[j] || j == -1)	// p 的第一个字符不匹配或者 p[j] == s[i]
		{
			++i;
			++j;
		}
		else 
		{
			j = next[j];	// s[i] != p[j],j 跳转回到最大前缀的最后一个位置
		}
	}
	if(j == pLen)
		return i - j;
	return -1;
}
```

### 5. 二叉树的遍历方法

**前序遍历**：先访问根结点，在访问左节点，最后访问右节点

```shell
// 递归实现
void preorder_traverse(BiTree *tree)
{
	if(tree)
	{
		cout << tree->val << endl;
		preorder_traverse(tree->leftChild);
		preorder_traverse(tree->rightChild);
	}
}
// 非递归实现
void preorder_traverse(BiTree *tree)
{
	std::stack<BiTree *> node_stack;
	while(tree != NULL || !node_stack.empty())
	{
		if(tree != NULL)
		{
			cout << tree->val << endl;
			node_stack.push(tree);
			tree = tree->leftChild;
		}
		else
		{
			tree = node_stack.top();
			node_stack.pop();
			tree = tree->rightChild;
		}
	}
}
```



**中序遍历**：先访问左结点，在访问根结点，最后访问右结点

```shell
// 递归实现
void inorder_traverse(BiTree * tree)
{
	if(tree == NULL)
	{
		cout << "empty tree" << endl;
		return;
	}
	
	if(tree != NULL)
	{
		inorder_traverse(tree->leftChild);
		cout << tree->val << endl;
		inorder_traverse(tree->rightChild);
	}
}

// 非递归实现
viod inorder_traverse(BiTree *tree)
{
	std::stack<BiTree *> node_stack;
	while(tree != NULL || !node_stack.empty())
	{
		if(tree != NULL)
		{
			node_stack.push(tree);
			tree = tree->leftChild;
		}
		else
		{
			tree = node_stack.top();
			cout << tree->val << endl;
			node_stack.pop();
			tree = tree->rightChild;
		}
	}
}
```

**后序遍历**：先访问左结点，在访问右结点，最后访问根结点

```shell
// 递归实现
void postorder_traverse(BsTree *tree)
{
	if(tree != NULL)
	{
		postorder_traverse(tree->leftChild);
		postorder_traverse(tree->rightChild);
		cout << tree->val << endl;
	}
}

// 非递归实现
// 需要一个游标来判断是否遍历完左右结点
void postorder_traverse(BiTree *tree)
{	
	std::stack<BiTree *> node_stack;
	BiTree *label_node = tree;
	
	while(tree != NULL || !node_stack.empty())
	{
		if(tree != NULL)
		{
			node_stack.push(tree);
			tree = tree->leftChild;
		}
		else
		{
			tree = node_stack.top();
			
			if(tree->right == NULL || tree->right == label_node)
			{
				node_stack.pop();
				cout << tree->val << endl;
				label_node = tree;
				tree = NULL;
			}
			else
			{
				tree = tree->rightChild;
			}
		}
	}
}
```

**层序遍历**：按照二叉树从上到下，从左到右依次遍历每个结点

```shell
void levelorder_traverse(BiTree *tree)
{
	std::queue<BiTree *> node_queue;
	node_queue.push(tree);
	while(!node_queue.empty())
	{
		BiTree * temp_node = node_queue.front();
		cout << temp_node->val << endl;
		node_stack.pop();
		
		if(temp_node->leftChild != NULL)
		{
			node_queue.push(temp_node->leftChild);
		}
		if(temp_node->rightChild != NULL)
		{
			node-queue.push(temp_node->rightChild);
		}
	}
}
```

### 6. 赫夫曼编码

**赫夫曼算法描述**：

1. 根据给定的 n 个权值{w<sub>1</sub>,w<sub>2</sub>,w<sub>3</sub>,...,w<sub>n</sub>}构成n棵二叉树的集合F={T<sub>1</sub>,T<sub>2</sub>,...,T<sub>n</sub>}，其中每棵二叉树 T<sub>i</sub> 中只有一个带权为w<sub>i</sub>的根结点，其左右子树均为空
2. 在 F 中选取两棵根结点的权值最小的树作为左右子树构造一棵新的二叉树，且置新的二叉树的跟结点的权值为其左右子树上根结点的权值之和
3. 在 F 中删除这两棵树，同时将新得到的二叉树加入到 F 中
4. 重复步骤 2 和步骤 3，知道 F 只含一棵树为止，这棵树就是赫夫曼树

**赫夫曼编码**

设需要编码的字符集为{d<sub>1</sub>,d<sub>2</sub>,...,d<sub>n</sub>},各个字符出现的次数或频率集合为{w<sub>1</sub>,w<sub>2</sub>,w<sub>3</sub>,...,w<sub>n</sub>},以d<sub>1</sub>,d<sub>2</sub>,...,d<sub>n</sub>作为叶子结点，以w<sub>1</sub>,w<sub>2</sub>,w<sub>3</sub>,...,w<sub>n</sub>作为相应叶子结点的权值构造赫夫曼树。

规定生成的赫夫曼树的左子树代表0 0，右子树代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。

### 7. 回溯算法

回溯算法：也叫试探法，一种系统的搜索问题的解的方法，基本思想是从一条路开始往前走，能进则进，不能进则退回上一步换一条路试一试，也就是在包含问题的所有解的解空间树中，按照深度优先的策略从根节点出发搜索解空间树。

解题步骤：

1.定义一个解空间，它包含问题的解；
2.利用适于搜索的方法组织解空间；
3.利用深度优先法搜索解空间；
4.利用限界函数避免移动到不可能产生解的子空间。

注意

- 回溯法存在会退到祖先结点的过程，所需要保存搜索过的结点，通常有两种方法：一是用自定义栈来保存；二是采用递归方法
- 避免无效搜索的方法：一是用约束函数在扩展结点处剪除不满足约束条件的路劲；二是用限界函数减去得不到问题的解或者最优解的路劲。这两类称为剪枝函数

八皇后问题：

[回溯算法详解]: https://blog.csdn.net/Marmara01/article/details/84727406?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-5
[八皇后问题]:https://www.cnblogs.com/huwt/p/10749234.html