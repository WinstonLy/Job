## 一 概述

### 1.1 基本特征

**并发**：一段时间内运行多个程序，操作系统引入进程和线程，使程序并发运行

**并行**：同一时刻运行多个指令，需要硬件支持，如流水线、多核处理器、分布式计算系统

**共享**：系统资源可被多个并发进程共同使用，分为互斥共享和同时共享

**虚拟**：一个物理实体转换为多个逻辑实体，分为时分复用和空分复用技术，多进程在同一处理器并发执行采用时分复用，虚拟内存采用空分复用

**异步**：进程不是一次性执行完

### 1.2 基本功能

**进程管理**：进程控制、进程同步、进程通信、死锁处理、处理机调度等。

**内存管理**：内存分配、地址映射、内存保护与共享、虚拟内存等。

**文件管理**：文件存储空间的管理、目录管理、文件读写管理和保护等。

**设备管理**：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。

主要包括缓冲管理、设备分配、设备处理、虛拟设备等。

### 1.3 系统调用

用户程序需要使用内核态的功能，通过系统调用进入内核，由操作系统代为完成

### 1.4 大内核与微内核

**大内核**：将操作系统功能作为一个紧密结合的整体放到内核

**微内核**：你骄傲给操作系统的一部分功能移出内核成为独立的模块，微内核运行在内核态，其他模块运行在用户态

### 1.5 中断分类

**外中断**：由 CPU 执行指令以外事件引起，如 I/O 中断，时钟中断，控制台终端等

**异常**：由 CPU 执行指令的内部事件引起，如非法操作码，地址越界。算术溢出等

**陷入**：在用户程序中使用系统调用

## 二 进程管理

### 2.1 进程与线程

**进程**：资源分配的基本单位，进程控制块（PCB）描述进程的基本信息和运行状态，进程创建和撤销都是对 PCB 进行操作

**线程**：独立调度的基本单位，一个进程可有多个线程，他们共享进程资源

**区别**：

- 拥有资源：进程进行资源分配，线程不拥有资源，访问隶属于进程的资源
- 调度：线程是独立调度的基本单位
- 系统开销：创建进程或撤销进程的开销远远大于创建或撤销线程的开销（分配回收资源），进程切换的开销也远远大于线程切换的开销（CPU环境保存设置）
- 通信：线程可直接读写同意进程中的数据进行通信，进程间需要 IPC

### 2.2 进程状态间的切换

![进程状态切换](D:\workspace\document\image\进程状态切换.png)

ready：就绪状态，等待被调度

running：运行状态

waiting：阻塞状态，等待资源

- 只有就绪态和运行态可相互转换，涉及 CPU 时间片的分配
- 阻塞状态是缺少需要的资源（不包括 CPU 时间片）从而由运行态转换而来

### 2.3 进程调度算法

不同环境的调度算法不同

**批处理系统**：没有过多用户操作，保证吞吐量和周转时间（从提交到终止的事件）

- 先来先服务（FCFS）：非抢占式，按请求顺序调度，有利于长作业，不利于短作业
- 短作业优先（SJF）：非抢占式，按估计运行时间最短顺序调度，长作业可能会一直等待
- 最短剩余时间优先（SRTN）：抢占式，按剩余运行时间的顺序调度，

**交互式系统**：有大量用户交互操作，目标是快速地进行响应

- 时间片轮转：所有就绪进程按 FCFS 原则排成队列，每次调度将 CPU 时间片分配给队首进程，时间片用完之后，停止执行，并送往队列末尾，同时将 CPU 时间片分配给对手进程。算法效率与时间片大小有关系。

- 优先级调度：为每个进程分配一个优先级，按优先级进行调度，可随时间推移增加等待进程的优先级

- 多级反馈队列：多级队列为需要连续执行多个时间片的进程考虑。每个队列分配一个时间片，当前队列未执行完的进程进入下一个队列继续执行，必须等到当前队列所有进程执行相应的时间片之后才会调度进入下一个队列的进程

    ![](D:\workspace\document\image\多级反馈调度.png)

**实时系统**：要求一个请求在一个确定时间内得到响应

​	分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时

### 2.4 进程同步

**临界区**：对临界资源进行访问的那段代码称为临界区，为了互斥访问临界资源，每个进程在进入临界区之前，需要进行检查

**同步与互斥**：

- 同步：多个进程由于合作产生的直接制约关系，使进程有一定的先后执行的关系
- 互斥：多个进程在同一个时刻只有一个进程能进入临界区
- 信号量：一个整型变量，可对其执行 down 和 up 操作
    - down：如果信号量大于 0，执行 -1 操作；等于 0，进程睡眠等待信号量大于 0
    - up：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作
    - 如果信号量的取值只能为 0 或 1，就成为了互斥量，0 表示临界区加锁，1 表示临界区解锁
- 管程：使用信号量机制实现生产者消费者问题，需要客户端代码做很多控制，管程将控制代码独立出来，降错，调用容易；在一个时刻只能由一个进程使用管程

### 2.5 进程通信

进程同步和进程通信的区别

- 进程同步：控制多个进程按照一定顺序执行
- 进程融信：进程间传输信息

**管道**：管道通过调用 `pipe `函数创建，`fd[0]`用于读，`fd[1]`用于写

```shell
#include <unistd.h>
int pipe(int fd[2]);
```

- 只支持半双工通信（单向交替传输）
- 只能在父子进程或者兄弟进程中使用

![](D:\workspace\document\image\PIPE进程间通信.png)

**FIFO**：命名管道，去除了管道只能在父子进程中使用的限制

```shell
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO常用于客户-服务器应用程序，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据

![](D:\workspace\document\image\FIFO进程通信.png)

FIFO最大的特性就是每个FIFO都有一个路径名与之相关联，从而允许无亲缘关系的任意两个进程间通过FIFO进行通信。所以，FIFO的两个特性：

- 和管道一样，FIFO仅提供半双工的数据通信，即只支持单向的数据流；
- 和管道不同的是，FIFO可以支持任意两个进程间的通信

**消息队列**：

- 独立于读写进程存在，从而避免 FIFO 中同步管道的打开和关闭时可能产生的困难
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法
- 可根据消息类型有选择的接收消息，不像 FIFO 默认的接受

**信息量**：相当于一个计数器，用于为多个进程提供对共享数据对象的访问

**共享存储**：允许多个进程共享一个给定的存储区，需要使用信号量用来同步对共享存储的访问，多个进程可以将同一个文件映射到他们的地址空间实现共享内存

**套接字**：可用于不同机器之间的进程通信

## 三 死锁

### 3.1 什么是死锁

多线程和多进程改善了系统资源的利用率并提高了系统的处理能力，但并发执行也可能造成死锁问题。

死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的僵局，若无外力作用，这些进程（线程）都将无法向前推进，死锁会浪费大量系统资源，甚至导致系统崩溃

- 参与死锁的进程数至少为两个
- 参与死锁的所有进程均等待资源
- 参与死锁的进程至少有两个已经占有资源

饥饿是指一个进程一直得不到资源，死锁与饥饿都是由于竞争进程资源而引起的，饥饿不占有资源，死锁一定占有资源

### 3.2 资源的类型

**可重用资源和消耗性资源**

可重用资源（永久性资源）：可被多个进程多次使用，如所有硬件

- 只能分配给一个进程使用，不允许多个进程共享
- 进程在使用可重用资源时，必须按照请求资源、使用资源、释放资源这样的顺序
- 系统中每一类可重用资源中的单元数目是相对固定的，在运行期间不可创建，也不能删除

消耗性资源（临时性资源）：由进程在运行期间动态的创建和消耗的

- 在进程运行期间可以不断变化，有时可能为 0
- 在运行期间，课不断创造课消耗性资源的单元
- 在运行期间，可请求若干个可消耗性资源单元，用于进程自己消耗，不再将它们返回给该类资源类中

**可抢占资源和不可抢占资源**

可抢占资源：某进程获得这类资源后，该资源能再被其他进程或系统抢占，这类资源不会引起死锁，CPU 和主存属于可抢占性资源

不可抢占资源：一旦系统把这类资源分配给进程后，就不能将它强行收回，只能在进程用完后自行释放，磁带、打印机属于不可抢占性资源

### 3.3 死锁产生的原因

**竞争不可抢占资源引起死锁**：只有对不可抢占资源的竞争才能产生死锁，对可抢占资源的竞争是不会引起死锁的

**竞争可消耗资源引起死锁**：进程间通信的消息

**进程推进顺序不当引起死锁**：一种因为所需资源被占用而阻塞，另一种因为等待对方的资源导致死锁

### 3.4 死锁产生的四个必要条件

- 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有
- 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。
- 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
- 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。

### 3.5 处理死锁的方法

- 预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。
    - 破坏互斥条件（危险）
    - 破坏等待并占有条件：一次性分配方案；每个进程申请新资源时释放所占有资源
    - 破坏不可抢占条件
    - 破坏循环等待条件
- 避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。
    - 有序资源分配法：按某种规则为系统中所有资源编号，申请时必须以上升次序
    - 银行家算法，详见[银行家算法](https://blog.csdn.net/qq_33414271/article/details/80245715?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)
    - 加锁技术：枷锁顺序，加锁时限，死锁检测
- 检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。
- 解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来
    - 资源剥夺法，挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程
    - 撤销进程法：强制撤销部分，甚至全部死锁进程并剥夺这些进程的资源
    - 进程回退法：让一个或多个进程回退到足以回避死锁的地步



## 四 内存管理

计算机的存储器层次结构：少量的非常快速、昂贵、易变的高速缓存(Cache)；若干兆字节的中等速度、中等价格、易变的主存储器(RAM)，数百兆或数千兆的低速、廉价、不易变的磁盘

计算机系统结构如下图，一部分负责控制、一部分负责执行、一部分负责存储

![计算机系统结构](/media/winston/本地磁盘/Job/document/image/计算机结构.png)

### 4.1 内存管理的功能

- 内存空间的分配和回收

    由操作系统完成主存储器空间的分配和管理，是程序员拜托存储分配的麻烦，提高编程效率

- 地址转换

    提供地址变换功能，把逻辑地址转换成相应的物理地址

- 存储保护和存储共享

    保证程序在各自的存储空间内运行，同时充分利用内存空间，共享内存中存放的信息

- 内存空间的扩充

    利用虚拟存储技术和自动覆盖技术，从逻辑上扩充内存

### 4.2 基本概念

- 虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址
- 逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址
- 物理地址：实际物理内存中所看到的存储地址称为物理地址
- 逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间
- 线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间
- 物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间
- MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路
- 基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算
- 偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值

- 地址重定位：把程序相对地址空间的逻辑地址转换成存储空间的绝对地址的过程

**虚拟内存**：每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块,称为**页**(Page).每个页都是一段连续的地址。对于进程来看,逻辑上貌似有很多内存空间，其中**一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)**，还有一些没加载在内存中的对应在硬盘上。

- 使用虚拟内存，扩大了地址空间、能进行内存保护、能公平分配内存、可通过虚拟内存共享实现进程通信
- 虚拟内存管理用到的数据结构占用额外的内存、到物理地址的转换增加指令执行时间、页面换入换出需要磁盘 I/O,增加运行时间、一页只有一部分数据的话会浪费内存

**内存碎片**：多次内存分配导致的空白段，分配给程序的存储空间没有用完的存储块为内碎片，空间太小无法分配给任何程序的存储空间为外碎片



### 4.3 内存管理的方式

内存管理有哪几种方式
常见的内存管理方式有块式管理、页式管理、段式和段页式管理。

- 块式管理：把主存分为一大块一大块的，当所需的程序片段不在主存时就分配一块主存空间，把程序片段load入主存，就算所需的程序片段只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50%的内存空间，但是易于管理。

- 页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，这种方法的空间利用率要比块式管理高很多；页是信息的物理单位，分页是为了提高内存的利用率，由于系统管理的需要

- 段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高得多，但是也有另外一个缺点。一个程序片段可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。段是信息的逻辑单位，分段是为了更好的满足用户的需要

- 段页式管理：结合了段式管理和页式管理的优点。把主存先分成若干段，每个段又分成若干页。段页式管理每取一护具，要访问3次内存

### 4.4 页式存储管理

将逻辑地址空间划分为固定大小的页，将物理内存划分为同样大小的页框，页面一般是 2 的整数幂，每一个程序有一个页表，用来记录各个页在内存中所对应的块（页框）

**地址结构**：前一部分为页号 P，后一部分为页内偏移量 W

**地址变换机制**

![](/media/winston/本地磁盘/Job/document/image/页式存储地址变换.png)

查进程页表得页内偏移地址和物理页号，得到物理页面号，最后得到物理地址

![](/media/winston/本地磁盘/Job/document/image/页表地址转换.png)

​		第一次用来查找页表将操作数的 逻辑地址变换为物理地址；

​        第二次完成真正的读写操作

**页面置换算法**

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法的主要目标：使页面置换频率最低（也就是缺页率最低）

- 最佳算法（OPT）：所选择被换出的页面将是最长时间内不再被访问，通常可保证获得最低的缺页率
- 最近最久未使用算法（LRU）：将最近最久未使用的页面换出，采用链表
- 最近未使用（NRU）
- 先进先出（FIFO）：选择换出的页面是最先进入的页面
- 最不经常使用淘汰算法（LLFU）：换出一段时间内访问次数最少的页面

### 4.5 段式存储管理

段式存储管理要求将每个程序的地址空间按程序自身的逻辑化为若干段，每个段都有一个唯一的内部段号

**地址结构**：逻辑地址由段号 S 与偏移量 W两部分组成

**地址变换机制**

![](/media/winston/本地磁盘/Job/document/image/段式存储地址变换.png)

![](/media/winston/本地磁盘/Job/document/image/段式地址转换.png)

在段式 管理系统中，整个进程的地址空间是二维的，即其逻辑地址由段号和段内地址两部分组成。

>**磁盘结构**
>
>- 盘面(Platter)：一个磁盘有多个盘面
>
>- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道
>
>- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，最小的物理存储单位
>
>- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）
>
>- 制动手臂（Actuator arm）：用于磁道之间移动磁头
>
>- 主轴（Spindle）：使整个盘面转动
>
>- ![磁盘结构图](D:\workspace\document\image\磁盘结构图.png)
>
>    **磁盘调度算法**
>
>    读写一个磁盘块的时间的影响因素有：
>
>    - 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
>    - 寻道时间（制动手臂转动，使得磁头移动到适当的磁道上）
>    - 实际的数据传输时间
>
>    磁盘调度的主要目标是使磁盘的平均寻道时间最短
>
>    - 先来先服务（FCFS），按磁盘请求的顺序进行调度
>    - 最短寻道时间优先（SSTF），优先调度与当前磁头所在磁道距离最近的磁道
>    - 电梯算法（SCAN），总是按一个方向进行磁盘调度，指导该方向上没有未完成的磁盘请求，然后改变方向

##  五 链接

### 5.1 编译系统

对于一个简单的`hello.c`文件，编译的流程如下

![编译系统](D:\workspace\document\image\编译系统.png)

- 预处理阶段：处理以 # 开头的预处理命令
- 编译阶段：翻译成汇编文件
- 汇编阶段：将汇编文件翻译成可重定位目标文件
- 链接阶段：将可重定位目标文件和`printf.o`等单独编译好的目标文件进行合并，得到最终的可执行文件

### 5.2 静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件为输出，编译器主要有两个任务：

- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用和一个符号定义关联起来
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些富豪的引用，使得他们指向这个内存位置

**目标文件**

- 可执行目标文件：可以直接在内存中执行；
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；

### 5.3 动态链接

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

## 六 操作系统

操作系统提供的服务：作业管理、文件管理、存储管理、输入输出设备管理、进程及处理机管理

### 6.1 中断和系统调用

中断就是计算机在执行程序的时候，出现某些特殊事情，使得 CPU 暂停对程序的执行，转而去执行处理这一事件的程序。

中断一般分为三类：

1. 由计算机硬件异常或故障引起的中断，称为内部异常中断；
2. 由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断）；
3. 由外部设备请求引起的中断，称为外部中断。简单来说，对中断的理解就是对一些特殊事情的处理。

典型的中断优先级：

机器错误 > 时钟 > 磁盘 > 网络设备 > 终端 > 软件中断

**系统调用**

进程的执行在系统上的两个级别：用户级和核心级，也叫用户态和系统态

程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。

那么用户态和核心态之间的区别：

	1. 用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址

 	2. 某些机器指令是特权指令，在用户态下执行特权指令会引起错误