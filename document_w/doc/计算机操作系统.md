## 一 概述

操作系统(Operating System, OS)是指**控制和管理**整个计算机系统的硬件和软件资源，并合理地**组织调度**计算机的工作和资源的分配，以提供给用户和其他软件方便的**接口和环境**的程序集合。

### 1.1 基本特征

**并发**：==**同一时间间隔**==内运行多个程序，操作系统引入进程和线程，使程序并发运行

**并行**：==同一时刻==运行多个指令，需要硬件支持，如流水线、多核处理器、分布式计算系统

>同一时间间隔：一段时间内宏观上有多道程序在执行，但在每一时刻单处理器环境下仅有一个程序执行，所以微观上这些程序分时交替进行，**操作系统的并发性通过分时实现**

**共享**：系统资源可被多个并发进程共同使用，分为互斥共享和同时共享

- 互斥共享方式：==规定一段时间内只允许一个进程访问该资源==，这种资源叫做临界资源或独占资源，例如打印机、磁带机等物理设备
- 同时共享方式：==允许在一段时间内由多个进程同时进行访问==，这里的同时指的是宏观上的，微观上是交替地堆该资源进行访问，也就是==分时==的方式共享，例如磁盘设备
- 并发和共享互为存在条件，并发为共享提供前提，共享为并发顺利执行提供管理

**虚拟**：一个物理实体转换为多个逻辑实体，分为时分复用和空分复用技术，例如虚拟处理器、虚拟内存和虚拟外部设备等。多进程在同一处理器并发执行采用时分复用，虚拟内存采用空分复用

**异步**：在多道程序环境下，允许多个进程并发执行，但由于资源受限，进程执行不是一贯到底，而是走走停停，不会一次执行完。

### 1.2 基本功能

**进程管理(CPU管理)**：进程控制、进程同步、进程通信、死锁处理、处理机调度等。

**内存管理**：内存分配、地址映射、内存保护与共享、虚拟内存等。

**文件管理**：文件存储空间的管理、目录管理、文件读写管理和保护等。

**设备管理**：完成用户的 I/O 请求，方便用户使用各种设备，并提高设备的利用率。主要包括缓冲管理、设备分配、设备处理、虛拟设备等。



### 1.3 系统调用

用户程序需要使用内核态的功能（存储分配，进行IO传输、管理文件等），通过系统调用进入内核，由操作系统代为完成

操作系统在具体实现上分为：**用户态(用户程序）和核心态（内核）**

- 核心态：与硬件关联紧密的模块（时钟管理、中断处理、设备驱动等）和运行频率较高的程序（内存管理，进程管理、设备管理）
- 用户态：用户自编程序或者系统外层的应用程序

>用户态转核心态的例子：
>
>- 用户程序要求操作系统的服务，即系统调用
>- 发生一次中断
>- 用户程序产生一个错误状态
>- 用户程序企图执行一条特权指令
>
>用户态进入核心态，不仅仅状态切换，而且使用的堆栈也可能需要用户堆栈切换为系统堆栈

**大部分操作系统内核包括时钟管理、中断机制、原语、系统控制的数据结构和处理**

### 1.4 大内核与微内核

**大内核**：将操作系统功能作为一个紧密结合的整体放到内核；但层次之间交互关系复杂，内核代码维护困难

**微内核**：操作系统的最基本的功能移出内核成为独立的模块，微内核运行在内核态，其他模块运行在用户态；频繁在用户和内核切换，切换的开销大

### 1.5 中断分类

**外中断**：由 CPU 执行指令以外事件引起，如 I/O 中断，时钟中断，控制台终端等

**异常**：由 CPU 执行指令的内部事件引起，如非法操作码，地址越界。算术溢出等

**陷入**：在用户程序中使用系统调用

## 二 进程管理

### 2.1 进程与线程

**进程**：资源分配的基本单位，进程控制块（PCB）描述进程的基本信息和运行状态，进程创建和撤销都是对 PCB 进行操作

​	引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量

- PCB：描述进程的基本情况和运行状态的数据结构，能保证进程独立运行
- 进程映像（实体）：程序段+PCB+相关数据段
- 进程：进程是进程实体的运行过程，是系统进行**资源分配**和调度的一个独立单位
    - 动态性：进程是程序的一次执行，有创建、活动、暂停、终止
    - 并发性：多个进程实体，同存于内存中，能在同一段时间内同时运行
    - 独立性：进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位
    - 异步性：由于进程的相互制约，使进程具有执行的间断性，即进程按各自独立的、 不可预知的速度向前推进
    - 结构性：每个进程都配置一个PCB对其进行描述

>**进程的组织**：控制块、程序段和数据段
>
>- 进程控制块：PCB是进程实体的一部分，是进程存在的唯一标志。
>
>    当创建一个进程时，系统为该进程建立一个PCB；当进程执行时，系统通过其PCB 了 解进程的现行状态信息，以便对其进行控制和管理；当进程结束时，系统收回其PCB,该进 程随之消亡。
>
>- 程序段：程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可以被多个进程共享，就是说多个进程可以运行同一个程序。
>
>- 数据段：一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。

**线程**：**独立调度和分派**的基本单位，一个进程可有多个线程，他们共享进程资源

​		引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能

-  程序执行流的最小单元，由线程ID、程序计数器、寄存器集合、堆栈组成
- 不拥有自己的系统资源，共享进程所拥有的全部资源
- 线程在运行中出现间断性，有就绪、阻塞和运行三种基本状态
- 线程是处理机的独立调度单位，多个线程是可以并发执行的

**区别**：

- 拥有资源：进程进行资源分配，线程不拥有资源，访问隶属于进程的资源
- 调度：线程是独立调度的基本单位
- 系统开销：创建进程或撤销进程的开销远远大于创建或撤销线程的开销（分配回收资源），进程切换的开销也远远大于线程切换的开销（CPU环境保存设置）
- 通信：线程可直接读写同意进程中的数据进行通信，进程间需要 进程同步和互斥手段的辅助

### 2.2 进程状态间的切换

![进程状态切换](..\image\进程五种状态机的转换.png)

ready：就绪状态，等待被调度，缺乏处理机

running：运行状态

waiting：阻塞状态，等待资源

- 只有就绪态和运行态可相互转换，涉及 CPU 时间片的分配
- 阻塞状态是缺少需要的资源（不包括 CPU 时间片）从而由运行态转换而来

创建状态：进程正在创建，尚未到就绪状态

结束状态：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行

>**进程控制**
>
>- 进程创建：允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程
>    - 为新进程分配一个唯一的进程标识号，并申请一个空白的PCB(PCB是有限的)。
>    - 为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间（在PCB 中体现）。
>    - 初始化PCB,主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。
>    - 如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。
>
>- 进程终止：引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。异常结束是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O故障等
>
>    - 根据被终止进程的标识符，检索PCB，从中读出该进程的状态。
>    - 若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。
>    - 若该进程还有子进程，则应将其所有子进程终止。
>    - 将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。
>    - 将该PCB从所在队列（链表）中删除。
>
>- 进程的阻塞和唤醒
>
>    正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态
>
>    - 找到将要被阻塞进程的标识号对应的PCB。
>    - 若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。
>    - 把该PCB插入到相应事件的等待队列中去
>
>    当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）调用唤醒原语(Wakeup)，将等待该事件的进程唤醒
>
>    - 在该事件的等待队列中找到相应进程的PCB。
>    - 将其从等待队列中移出，并置其状态为就绪状态。
>    - 把该PCB插入就绪队列中，等待调度程序调度。
>
>- 进程切换：进程切换是指处理机从一个进程的运行转到另一个进程上运行，这个过程中，进程的运行环境产生了实质性的变化
>
>    - 保存处理机上下文，包括程序计数器和其他寄存器。
>    - 更新PCB信息。
>    - 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。
>    - 选择另一个进程执行，并更新其PCB。
>    - 更新内存管理的数据结构。
>    - 恢复处理机上下文。

### 2.3 进程调度算法

不同环境的调度算法不同

处理机调度是**对处理机进行分配**，就是从就绪队列中，按照一定的算法（公平、髙效）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。

**批处理系统**：没有过多用户操作，保证吞吐量和周转时间（从提交到终止的事件）

- 先来先服务（FCFS）：非抢占式，按请求顺序调度，有利于长作业，不利于短作业
- 短作业优先（SJF）：非抢占式，按估计运行时间最短顺序调度，长作业可能会一直等待，出现饥饿现象，未考虑作业的紧迫程度
- 最短剩余时间优先（SRTN）：抢占式，按剩余运行时间的顺序调度，

**交互式系统**：有大量用户交互操作，目标是快速地进行响应

- 时间片轮转：所有就绪进程按 FCFS 原则排成队列，每次调度将 CPU 时间片分配给队首进程，时间片用完之后，停止执行，并送往队列末尾，同时将 CPU 时间片分配给对手进程。算法效率与时间片大小有关系。

- 优先级调度：为每个进程分配一个优先级，按优先级进行调度，可随时间推移增加等待进程的优先级

- 多级反馈队列：多级队列为需要连续执行多个时间片的进程考虑。每个队列分配一个时间片，当前队列未执行完的进程进入下一个队列继续执行，必须等到当前队列所有进程执行相应的时间片之后才会调度进入下一个队列的进程

    ![](..\image\多级反馈调度.png)

**实时系统**：要求一个请求在一个确定时间内得到响应

​	分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时

### 2.4 进程同步

**临界资源**：把一次仅允许一个进程使用的资源称为临界资源

**临界区**：对临界资源进行访问的那段代码称为临界区，为了互斥访问临界资源，每个进程在进入临界区之前，需要进行检查

- 进入区：检查是否可以进入临界区，设置正在访问临界区的标识，阻止其他进程
- 临界区：访问临界区资源的代码
- 退出区：将正在访问临界区的标志删除
- 剩余区：代码中的其余部分

**同步与互斥**：

- 同步：多个进程由于合作产生的**直接制约关系**，使进程有一定的先后执行的关系

    输入进程A通过单缓冲向进程B提供数据，缓冲区为空，进程B不能获取数据而阻塞；进程A将数据送入缓冲区，进程B唤醒；反之缓冲区满

- 互斥：多个进程在同一个时刻只有一个进程能进入临界区，间接制约关系

>实现临界区互斥的办法
>
>- 软件实现：单标志法，双标志法，双标志后检查

- 信号量：一个整型变量，可对其执行 down 和 up 操作，即“P操作”和“V操作”
    - down：如果信号量大于 0，执行 -1 操作；等于 0，进程睡眠等待信号量大于 0
    - up：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作
    - 如果信号量的取值只能为 0 或 1，就成为了互斥量，0 表示临界区加锁，1 表示临界区解锁
    
    ```c
    // 信号量实现同步
    semaphore S = 0;  //初始化信号量
    P1 ( ) {
        // …
        x;  //语句x
        V(S);  //告诉进程P2,语句乂已经完成
    }
    P2()）{
        // …
        P(S) ;  //检查语句x是否运行完成
        y;  // 检查无误，运行y语句
        // …
    }
    // 信号量实现互斥
    semaphore S = 1;  //初化信号量
    P1 ( ) {
        // …
        P(S);  // 准备开始访问临界资源，加锁
        // 进程P1的临界区
        V(S);  // 访问结束，解锁
        // …
    }
    P2() {
        // …
        P(S); //准备开始访问临界资源，加锁
        // 进程P2的临界区；
        V(S);  // 访问结束，解锁
        // …
    }
    ```
    
    
    
- 管程：使用信号量机制实现生产者消费者问题，需要客户端代码做很多控制，管程将控制代码独立出来，降错，调用容易；在一个时刻只能由一个进程使用管程

### 2.5 进程通信

进程同步和进程通信的区别

- 进程同步：控制多个进程按照一定顺序执行
- 进程通信（**IPC**）：进程间传输信息

**管道**：管道通过调用 `pipe `函数创建，会创建两个文件描述符：`fd[0]`用于读，`fd[1]`用于写

```shell
#include <unistd.h>
int pipe(int fd[2]);
```

- 只支持半双工通信（单向交替传输），有固定的读端和写端
- 只能在父子进程或者兄弟进程中使用

![](..\image\PIPE进程间通信.png)

**FIFO**：命名管道，去除了管道只能在父子进程中使用的限制，是一种文件类型

```shell
#include <sys/stat.h>
int mkfifo(const char *path, mode_t mode);
int mkfifoat(int fd, const char *path, mode_t mode);
```

FIFO常用于客户-服务器应用程序，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据

![](..\image\FIFO进程通信.png)

FIFO最大的特性就是每个FIFO都有一个路径名与之相关联，从而允许无亲缘关系的任意两个进程间通过FIFO进行通信。所以，FIFO的两个特性：

- 和管道一样，FIFO仅提供**半双工**的数据通信，即只支持单向的数据流；和管道不同的是，FIFO可以支持**任意两个进程间的通信**
- **FIFO 和路径名相关联**，以一种特殊设备文件形式存在于文件系统中

**消息队列**：是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。

- 独立于读写进程存在，进程终止时消息队列及其内容不会被删除
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法，消息具有特定的格式和优先级
- 可根据消息类型有选择的接收消息，不像 FIFO 默认的接受

**信息量**：相当于一个计数器，用于为多个进程提供对共享数据对象的访问，**实现进程之间的互斥和同步**

- 信号量用于进程间同步，若要在进程间传递数据需要结合共享内存
- 信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作
- 每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数

**共享存储**：允许多个进程共享一个给定的存储区，需要使用信号量用来同步对共享存储的访问，多个进程可以将同一个文件映射到他们的地址空间实现共享内存

1. 共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。
2. 因为多个进程可以同时操作，所以需要进行同步。
3. 信号量+共享内存通常结合在一起使用，信号量用来同步对共享内存的访问

**套接字**：可用于不同机器之间的进程通信

### 2.6 经典进程同步问题

- 生产者-消费者问题

    ```C++
    semaphore mutex=1; //临界区互斥信号量
    semaphore empty=n;  //空闲缓冲区
    semaphore full=0;  //缓冲区初始化为空
    producer () { //生产者进程
        while(1){
            produce an item in nextp;  //生产数据
            P(empty);  //获取空缓冲区单元
            P(mutex);  //进入临界区.
            add nextp to buffer;  //将数据放入缓冲区
            V(mutex);  //离开临界区,释放互斥信号量
            V(full);  //满缓冲区数加1
        }
    }
    consumer () {  //消费者进程
        while(1){
            P(full);  //获取满缓冲区单元
            P(mutex);  // 进入临界区
            remove an item from buffer;  //从缓冲区中取出数据
            V (mutex);  //离开临界区，释放互斥信号量
            V (empty) ;  //空缓冲区数加1
            consume the item;  //消费数据
        }
    }
    ```

    

## 三 死锁

### 3.1 什么是死锁

多线程和多进程改善了系统资源的利用率并提高了系统的处理能力，但并发执行也可能造成死锁问题。

死锁是指两个或两个以上的进程（线程）在运行过程中因争夺资源而造成的僵局，若无外力作用，这些进程（线程）都将无法向前推进，死锁会浪费大量系统资源，甚至导致系统崩溃

- 参与死锁的进程数至少为两个
- 参与死锁的所有进程均等待资源
- 参与死锁的进程至少有两个已经占有资源

饥饿是指一个进程一直得不到资源，死锁与饥饿都是由于竞争进程资源而引起的，饥饿不占有资源，死锁一定占有资源

### 3.2 资源的类型

**可重用资源和消耗性资源**

可重用资源（永久性资源）：可被多个进程多次使用，如所有硬件

- 只能分配给一个进程使用，不允许多个进程共享
- 进程在使用可重用资源时，必须按照请求资源、使用资源、释放资源这样的顺序
- 系统中每一类可重用资源中的单元数目是相对固定的，在运行期间不可创建，也不能删除

消耗性资源（临时性资源）：由进程在运行期间动态的创建和消耗的

- 在进程运行期间可以不断变化，有时可能为 0
- 在运行期间，课不断创造课消耗性资源的单元
- 在运行期间，可请求若干个可消耗性资源单元，用于进程自己消耗，不再将它们返回给该类资源类中

**可抢占资源和不可抢占资源**

可抢占资源：某进程获得这类资源后，该资源能再被其他进程或系统抢占，这类资源不会引起死锁，CPU 和主存属于可抢占性资源

不可抢占资源：一旦系统把这类资源分配给进程后，就不能将它强行收回，只能在进程用完后自行释放，磁带、打印机属于不可抢占性资源

### 3.3 死锁产生的原因

**竞争不可抢占资源引起死锁**：只有对不可抢占资源的竞争才能产生死锁，对可抢占资源的竞争是不会引起死锁的

**竞争可消耗资源引起死锁**：进程间通信的消息，进程A等待进程B地消息，进程B也等待进程A的消息

**进程推进顺序不当引起死锁**：一种因为所需资源被占用而阻塞，另一种因为等待对方的资源导致死锁

### 3.4 死锁产生的四个必要条件

- 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有
- 不可剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。
- 请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
- 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被链中下一个进程所请求。

### 3.5 处理死锁的方法

- 预防死锁：通过设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或几个条件，来防止死锁的发生。
    - 破坏互斥条件（危险）
    - 破坏等待并占有条件：一次性分配方案；每个进程申请新资源时释放所占有资源
    - 破坏不可抢占条件
    - 破坏循环等待条件
    
- 避免死锁：在资源的动态分配过程中，用某种方法去防止系统进入不安全状态，从而避免死锁的发生。
    - 有序资源分配法：按某种规则为系统中所有资源编号，申请时必须以上升次序
    - 银行家算法，详见[银行家算法](https://blog.csdn.net/qq_33414271/article/details/80245715?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)
    - 加锁技术：枷锁顺序，加锁时限，死锁检测
    
- 检测死锁：允许系统在运行过程中发生死锁，但可设置检测机构及时检测死锁的发生，并采取适当措施加以清除。

    每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。

- 解除死锁：当检测出死锁后，便采取适当措施将进程从死锁状态中解脱出来
    - 资源剥夺法，挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程
    - 撤销进程法：强制撤销部分，甚至全部死锁进程并剥夺这些进程的资源
    - 进程回退法：让一个或多个进程回退到足以回避死锁的地步

- 鸵鸟政策

  因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

  当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

## 四 内存管理

计算机的存储器层次结构：少量的非常快速、昂贵、易变的高速缓存(Cache)；若干兆字节的中等速度、中等价格、易变的主存储器(RAM)，数百兆或数千兆的低速、廉价、不易变的磁盘

计算机系统结构如下图，一部分负责控制、一部分负责执行、一部分负责存储

![计算机系统结构](/media/winston/本地磁盘/Job/document/image/计算机结构.png)

### 4.1 内存管理的功能

- 内存空间的分配和回收

    由操作系统完成主存储器空间的分配和管理，是程序员拜托存储分配的麻烦，提高编程效率

- 地址转换

    提供地址变换功能，把逻辑地址转换成相应的物理地址

- 存储保护和存储共享

    保证程序在各自的存储空间内运行，同时充分利用内存空间，共享内存中存放的信息

- 内存空间的扩充

    利用虚拟存储技术和自动覆盖技术，从逻辑上扩充内存

### 4.2 基本概念

- 虚拟地址：用户编程时将代码（或数据）分成若干个段，每条代码或每个数据的地址由段名称 + 段内相对地址构成，这样的程序地址称为虚拟地址
- 逻辑地址：虚拟地址中，段内相对地址部分称为逻辑地址
- 物理地址：实际物理内存中所看到的存储地址称为物理地址
- 逻辑地址空间：在实际应用中，将虚拟地址和逻辑地址经常不加区分，通称为逻辑地址。逻辑地址的集合称为逻辑地址空间
- 线性地址空间：CPU地址总线可以访问的所有地址集合称为线性地址空间
- 物理地址空间：实际存在的可访问的物理内存地址集合称为物理地址空间
- MMU(Memery Management Unit内存管理单元)：实现将用户程序的虚拟地址（逻辑地址） → 物理地址映射的CPU中的硬件电路
- 基地址：在进行地址映射时，经常以段或页为单位并以其最小地址（即起始地址）为基值来进行计算
- 偏移量：在以段或页为单位进行地址映射时，相对于基地址的地址值

- 地址重定位：把程序相对地址空间的逻辑地址转换成存储空间的绝对地址的过程

**虚拟内存**：每个进程有用独立的逻辑地址空间，内存被分为大小相等的多个块,称为**页**(Page).每个页都是一段连续的地址。对于进程来看,逻辑上貌似有很多内存空间，其中**一部分对应物理内存上的一块(称为页框，通常页和页框大小相等)**，还有一些没加载在内存中的对应在硬盘上。

- 使用虚拟内存，扩大了地址空间、能进行内存保护、能公平分配内存、可通过虚拟内存共享实现进程通信
- 虚拟内存管理用到的数据结构占用额外的内存、到物理地址的转换增加指令执行时间、页面换入换出需要磁盘 I/O,增加运行时间、一页只有一部分数据的话会浪费内存

**内存碎片**：多次内存分配导致的空白段，分配给程序的存储空间没有用完的存储块为内碎片，空间太小无法分配给任何程序的存储空间为外碎片



### 4.3 内存管理的方式

内存管理有哪几种方式
常见的内存管理方式有块式管理、页式管理、段式和段页式管理。

- 块式管理：把主存分为一大块一大块的，当所需的程序片段不在主存时就分配一块主存空间，把程序片段load入主存，就算所需的程序片段只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50%的内存空间，但是易于管理。

- 页式管理：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，这种方法的空间利用率要比块式管理高很多；页是信息的物理单位，分页是为了提高内存的利用率，由于系统管理的需要

- 段式管理：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高得多，但是也有另外一个缺点。一个程序片段可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。段是信息的逻辑单位，分段是为了更好的满足用户的需要

- 段页式管理：结合了段式管理和页式管理的优点。把主存先分成若干段，每个段又分成若干页。段页式管理每取一护具，要访问3次内存

### 4.4 页式存储管理

将逻辑地址空间划分为固定大小的页，将物理内存划分为同样大小的页框，页面一般是 2 的整数幂，每一个程序有一个页表，用来记录各个页在内存中所对应的块（页框）

**地址结构**：前一部分为页号 P，后一部分为页内偏移量 W

**地址变换机制**

![](/media/winston/本地磁盘/Job/document/image/页式存储地址变换.png)

查进程页表得页内偏移地址和物理页号，得到物理页面号，最后得到物理地址

![](/media/winston/本地磁盘/Job/document/image/页表地址转换.png)

​		第一次用来查找页表将操作数的 逻辑地址变换为物理地址；

​        第二次完成真正的读写操作

**页面置换算法**

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法的主要目标：使页面置换频率最低（也就是缺页率最低）

- 最佳算法（OPT）：所选择被换出的页面将是最长时间内不再被访问，通常可保证获得最低的缺页率
- 最近最久未使用算法（LRU）：将最近最久未使用的页面换出，采用链表
- 最近未使用（NRU）
- 先进先出（FIFO）：选择换出的页面是最先进入的页面
- 最不经常使用淘汰算法（LLFU）：换出一段时间内访问次数最少的页面

### 4.5 段式存储管理

段式存储管理要求将每个程序的地址空间按程序自身的逻辑化为若干段，每个段都有一个唯一的内部段号

**地址结构**：逻辑地址由段号 S 与偏移量 W两部分组成

**地址变换机制**

![](/media/winston/本地磁盘/Job/document/image/段式存储地址变换.png)

![](/media/winston/本地磁盘/Job/document/image/段式地址转换.png)

在段式 管理系统中，整个进程的地址空间是二维的，即其逻辑地址由段号和段内地址两部分组成。

>**磁盘结构**
>
>- 盘面(Platter)：一个磁盘有多个盘面
>
>- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道
>
>- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，最小的物理存储单位
>
>- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）
>
>- 制动手臂（Actuator arm）：用于磁道之间移动磁头
>
>- 主轴（Spindle）：使整个盘面转动
>
>- ![磁盘结构图](D:\workspace\document\image\磁盘结构图.png)
>
>    **磁盘调度算法**
>
>    读写一个磁盘块的时间的影响因素有：
>
>    - 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
>    - 寻道时间（制动手臂转动，使得磁头移动到适当的磁道上）
>    - 实际的数据传输时间
>
>    磁盘调度的主要目标是使磁盘的平均寻道时间最短
>
>    - 先来先服务（FCFS），按磁盘请求的顺序进行调度
>    - 最短寻道时间优先（SSTF），优先调度与当前磁头所在磁道距离最近的磁道
>    - 电梯算法（SCAN），总是按一个方向进行磁盘调度，指导该方向上没有未完成的磁盘请求，然后改变方向

##  五 链接

### 5.1 编译系统

对于一个简单的`hello.c`文件，编译的流程如下

![编译系统](D:\workspace\document\image\编译系统.png)

- 预处理阶段：处理以 # 开头的预处理命令
- 编译阶段：翻译成汇编文件
- 汇编阶段：将汇编文件翻译成可重定位目标文件
- 链接阶段：将可重定位目标文件和`printf.o`等单独编译好的目标文件进行合并，得到最终的可执行文件

### 5.2 静态链接

静态链接器以一组可重定位目标文件为输入，生成一个完全链接的可执行目标文件为输出，编译器主要有两个任务：

- 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用和一个符号定义关联起来
- 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些富豪的引用，使得他们指向这个内存位置

**目标文件**

- 可执行目标文件：可以直接在内存中执行；
- 可重定位目标文件：可与其它可重定位目标文件在链接阶段合并，创建一个可执行目标文件；
- 共享目标文件：这是一种特殊的可重定位目标文件，可以在运行时被动态加载进内存并链接；

### 5.3 动态链接

静态库有以下两个问题：

- 当静态库更新时那么整个程序都要重新进行链接；
- 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。

共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点：

- 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中；
- 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。

## 六 操作系统

操作系统提供的服务：作业管理、文件管理、存储管理、输入输出设备管理、进程及处理机管理

### 6.1 中断和系统调用

中断就是计算机在执行程序的时候，出现某些特殊事情，使得 CPU 暂停对程序的执行，转而去执行处理这一事件的程序。

中断一般分为三类：

1. 由计算机硬件异常或故障引起的中断，称为内部异常中断；
2. 由程序中执行了引起中断的指令而造成的中断，称为软中断（这也是和我们将要说明的系统调用相关的中断）；
3. 由外部设备请求引起的中断，称为外部中断。简单来说，对中断的理解就是对一些特殊事情的处理。

典型的中断优先级：

机器错误 > 时钟 > 磁盘 > 网络设备 > 终端 > 软件中断

**系统调用**

进程的执行在系统上的两个级别：用户级和核心级，也叫用户态和系统态

程序的执行一般是在用户态下执行的，但当程序需要使用操作系统提供的服务时，比如说打开某一设备、创建文件、读写文件等，就需要向操作系统发出调用服务的请求，这就是系统调用。

那么用户态和核心态之间的区别：

	1. 用户态的进程能存取它们自己的指令和数据，但不能存取内核指令和数据（或其他进程的指令和数据）。然而，核心态下的进程能够存取内核和用户地址

 	2. 某些机器指令是特权指令，在用户态下执行特权指令会引起错误