[TOC]



​	

## 一 基本知识

### 1.1 `const`限定符

`const`叫常量限定符，用来限定特定变量，已通知编译器该变量不可修改。

C++ 中`const`的主要用法分为以下几类：

- 修饰基本数据类型
- 应用到函数中
- 在类中使用
- `const`修饰类对象，定义常量对象

#### 1.1.1 `cosnt `修饰基本数据类型

主要是修饰变量、引用和指针,声明的时候就要初始化

**修饰一般常量或数组**：

```shell
const int a = 10；
const int arr[3] = {1, 2, 3};
```

**修饰指针变量 * **:

- 如果`const`位于星号 * 的左侧，则`const`用来修饰指针所指向的变量，即指针指向为常量

- 如果`const`位于星号 * 的右侧，`const`就是修饰指针本身，即指针本身是常量

  ```cpp
  int x = 100;
  const int *a1 = &x;  /* int const *a2 = &x; */
  int* const a3 = &x;
  const int* const a = &x;
  ```

  

**修饰引用变量 &**：`const int &a = x;`

- 指向`const`对象的引用，不能通过引用来修改对象的值
- 将普通的引用绑定到`const`对象是不合法的

#### 1.1.2 `const`应用到函数中

- 作为参数的`const`修饰符

  调用函数的时候用相应的变量初始化`const`常量

- 作为函数返回值的`const`修饰符

  保护函数返回的指针指向的内容或引用的对象不能被修改

- 作为函数的`const`修饰符

  在函数定义的最后面加上`const`修饰，如：`A fun() const;`,表示不能修改除了函数局部变量以外的所在类的任何变量

#### 1.1.3 类中定义常量

**使用枚举类型**：

```cpp
class test
{
	enum {SIZE1 = 10, SIZE2 = 20};
}
```

**使用`const`**：不能在类声明中完成初始化`const`数据成员。

- **`cosnt`数据成员的初始化只能在类构造函数的初始化列表中进行。**

```cpp
class A
{
	const int SIZE = 10;    /* 错误 */
	A(int size);
	const int SIZE；
};
A::A(int size):SIZE(size){
	SIZE = size; /* 错误 */
}
```

**使用 static` const`**

```cpp
class Year
{
private:
	int y; 
public:
	static int const Inity;
public: 
	Year()
	{
		y=Inity;
	}
};
int const Year::Inity=1997;//静态变量的赋值方法,注意必须放在类外定义
```

#### 1.1.4 `const`定义常量对象，以及常量对象的用法

对于定义的`const`对象，只能调用`cosnt`修饰的函数，其余函数不能调用

```cpp
class test
{
public:
    test():x(1)
    {
        y=2;
    }
    ~test()
    {}
    void set(int yy)
    {
    }
    int getx() const
    {
    }
    const int x;
    int y;
};

void main()
{
	const test t;// 定义的一个const对象
	t.set(33);//error，set方法不是const修饰的方法，编译器会报错。
	t.getx();
}
```



### 1.2 引用

引用就是对象的另一个名字,主要用作函数的形式参数.引用是一种复合类型,通过变量名前添加`&`符号来定义.引用必须用与该引用同类型的对象初始化,

#### 1.2.1 引用是别名

对引用的操作实际上都是作用在该引用绑定的对象上

引用初始化后,就保持绑定到初始化时指向的对象,不可能将引用绑定到另一个对象.

#### 1.2.2 `const`引用

`const`引用是指向`const`对象的引用.

```cpp
const int iVal = 1024;
const int &refVal = iVal;    // ok
int &ref = iVal; 			 // error
refVal = 502;				 // error
```

不能通过修改引用来修改引用对象

将普通的引用绑定到`const`对象是不合法的

非`const`引用只能绑定到与该引用类型相同的对象,`const`引用可以绑定到不同但相关的类型的对象或绑定到右值.

>**typedef**:定义类型的同义词
>
>```cpp
>typedef int wage;
>wage hour, week;
>```
>
>**枚举**:枚举的定义包括关键字`enum`,其后是一个枚举类型名,和一个花括号括起来,用逗号分开的枚举成员.
>
>```cpp
>enum open_modes{input, output, append};
># 默认第一个枚举成员赋值为0,后面每个成员依次递增
>```

### 1.3 迭代器简介

除了使用下标访问`vector`对象的元素,还可以使用迭代器.迭代器是一种检查容器内元素并遍历元素的数据类型.

一般意义上指的是迭代器的概念,具体而言时指的是由容器定义的具体的iterator类型.

每种容器都定义了自己的迭代器类型,如`vector`:

```cpp
vector<int>::iterator iter;
```

* **begin和end操作**

  每种容器都定义了一对命名为`begin`和`end`的函数,用于返回迭代器.

  ```cpp
  // begin 返回的迭代器指向第一个元素
  vector<int>::iterator iter = ivec.begin();
  // end 返回的迭代器指向vector的末端元素的下一个位置
  ```


- **迭代器的解引用和自增运算**

  迭代器可用解引用操作符`*`来访问迭代器所指向的元素

  ```cpp
  *iter = 0;
  ```

  迭代器使用自增操作符向前移动迭代器指向容器中下一个元素

  ```cpp
  ++iter;
  ```

  由于`end`操作返回的迭代器不指向任何元素,不能进行解引用和自增操作

- **示例**

  ```cpp
  # 下标操作
  vector<int> iVec(10);
  for(vector<int>::size_type i = 0; i != iVec.size(); ++i)
  {
  	iVec[i] = 0;
  }
  # 迭代器操作
  vector<int> iVec(10);
  for(vector<int>::iterator iter = iVec.begin(); iter != iVec.end(); ++iter)
  {
  	*iter = 0;
  }
  ```

- **`const_iterator`**

  每种容器还定义了一种`const_iterator`的类型,只用于读取容器内元素,但不能改变其值.

- **迭代器的基本操作**

  ```cpp
  // 对迭代器对象加上或者减去一个整形值,即在迭代器所指元素之前(加)或之后(减) n 个元素的位置
  // 仅对 vector 和 deque 支持
  iter + n
  iter - n
  // 计算两个迭代器之间的距离,两个迭代器必须指向同一容器中的元素
  iter1 - iter2
  // 返回迭代器iter所指向的元素的引用
  *iter
  // 对iter进行解引用,获取指定元素中名为mem的成员
  iter->mem
  (*iter).mem
  // 给 iter 加 1,指向容器里的下一个元素
  ++iter
  iter++
  // 给 iter 减 1,指向容器里的前一个元素
  --iter
  iter--
  // 用`==`或`!=`操作符来比较两个迭代器,如果都指向同一个元素则相等,否则就不等.
  iter1 == iter2
  ```

- **迭代器范围**

  C++使用一对迭代器标记迭代器范围,这两个迭代器分别指向同一个容器中的两个元素或超出末端的下一位置,称为左闭合区间[first, last).

  当 first = last 时,迭代器所指空间为空.

- **一些容器操作会修改容器的内在状态或移动容器内的元素,这样会使指向被移动元素的迭代器失效**

### 1.4 三种内存分配方式
- 从静态存储区分配

  内存在程序编译的时候已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。

- 在栈上创建

  在执行函数时，函数内局部变量的存储单元可以在栈上创建，函数执行结束时，这些内存单元会自动被释放。
  栈内存分配运算内置于处理器的指令集，效率高，但是分配的内存容量有限。

- 从堆上分配

  亦称为动态内存分配。
  程序在运行的时候使用`malloc`或者`new`申请任意多少的内存，程序员自己负责在何时用`free`或`delete`释放内存。
  
  一旦删除指针所指向的对象，立即将指针置 0。
  动态内存的生命周期有程序员决定，使用非常灵活，但如果在堆上分配了空间，既有责任回收它，否则运行的程序会出现内存泄漏，频繁的分配和释放不同大小的堆空间将会产生内存碎片。

### 1.5 语句

**break 语句**

用于结束最近的`while、do while、for 或 switch`语句，并将程序的执行权传递给紧接在被终止语句之后的语句。

**continue 语句**

导致最近的循环语句的当前次迭代提前结束，对于`while`和`do while`语句继续求解循环条件；对于`for`循环，程序流程接着求解`for`语句头中的`expression`表达式。

**try 语句和异常处理**

C++的异常处理包括：

- **throw表达式**：错误检测部分使用这种表达式来说明遇到了不可处理的错误，通过`throw`表达式抛出异常。
- **try 块**：错误处理部分使用它来处理异常；**try语句块**以**try**关键字开始，并以一个或多个**catch子句**结束。

### 1.6 C++ 中的类型限定符

类型限定符提供了变量的额外信息。

| 限定符     | 含义                                                         |
| :--------- | :----------------------------------------------------------- |
| `const`    | **const**类型的对象在程序执行期间不能被修改改变。            |
| `volatile` | 修饰符 **volatile** 告诉编译器不需要优化volatile声明的变量，让程序可以直接从内存中读取变量。对于一般的变量编译器会对变量进行优化，将内存中的变量值放在寄存器中以加快读写效率。 |
| `restrict` | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。**主要用来修饰指针指向的内存不能被别的指针引用** |

### 1.7 C++预处理器

预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理器

所有的预处理器指令都是以`#`开头，不是 C++ 语句，不会以`;`结束

**#define预处理**：用于创建符号常量，通常称为**宏**

```cpp
/* 一般指令形式 */
#define 宏名 待替代内容
#define PI 3.1415

/* 带参数宏 */
#define MIN(a, b) (a<b ? a : b)
```

**条件编译**：有选择地对部分源程序进行编译（`#ifdef、#else、#endif`）

```cpp
#ifdef NULL
	#define NULL 0
#endif
```

- 可在调试时用宏来实现调试开关

**# 和 ## 运算符 **：

- **# 运算符**会把待替代内容转换为用括号引起来的字符串

  ```cpp
  #define MKSTR( x ) #x
  ......
  cout << MKSTR(HELLO C++) << endl; 		/* 输出字符串 HELLO C++ */
  ```

- **## 运算符**用于连接两个令牌，并用来取代宏

  ```cpp
  #define concat(a, b) a ## b
  ......
  int xy = 100;
  cout << concat(x, y);  /* 输出 100 */
  ```


###　1.8 文件和流

**`iostream`**标准库提供了`cin`和`cout`方法分别从标准输入读取流和向标准输出写入流

**`fstream`**标准库提供从文件读取流和向文件写入流的方法，定义了三个新的数据类型：

| 数据类型   | 描述                                                         |
| ---------- | ------------------------------------------------------------ |
| `ofstream` | 该数据类型表示输出文件流，用于创建文件并向文件写入信息       |
| `ifstream` | 该数据类型表示输入文件流，用于从文件读取信息                 |
| `fstream`  | 该数据类型表示文件流，同时具有输入输出功能，可以创建文件，向文件写入信息，从文件读取信息 |

**打开文件**：用`open`函数打开文件，`open`函数`fstream、ofstream、ifstream`对象的一个成员

```cpp
/* filename：要打开文件的名称和位置 */
/* mode：文件被打开的模式 */
void open(const char *filename, ios::openmode mode);
// mode 分为 ios::app（追加模式，写入到文件末尾）、ios::ate（文件打开后定位到文件末尾）、ios::in（打开文件用于读取）、ios::out（打开文件用于写入）、ios::trunc（如果文件存在，其内容在打开文件前被截断，即把文件长度设为 0）

// 实例

// writing on a text file
#include <fiostream.h>
int main () {
    ofstream out("out.txt");
    if (out.is_open()) 
    {
        out << "This is a line.\n";
        out << "This is another line.\n";
        out.close();
    }
    return 0;
}
 //结果: 在out.txt中写入：
 This is a line.
 This is another line 
   
// reading a text file
#include <iostream.h>
#include <fstream.h>
#include <stdlib.h>

int main () {
    char buffer[256];
    ifstream in("test.txt");
    if (! in.is_open())
    { cout << "Error opening file"; exit (1); }
    while (!in.eof() )
    {
         in.getline (buffer,100);
            cout << buffer << endl;
    }
    in.close();
    return 0;
}
//结果 在屏幕上输出
 This is a line.
 This is another line
  
```

**关闭文件**：C++程序终止时，会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件

​	利用`close()`函数来关闭文件

**写入文件**：利用流插入运算符（`<<`）向文件写入信息，向文件写入信息使用的是`ofstream`或`fstream`对象

**读取文件**：利用流提取运算符（`>>`）从文件读取信息，从文件读取信息使用的是`ofstream`或`fstream`对象

>`ignore()` 是`istream `类的成员函数，它的原型是：
>
>`istream & ignore(int n =1, int delim = EOF);`
>
>此函数的作用是跳过输入流中的 n 个字符，或跳过 `delim` 及其之前的所有字符，哪个条件先满足就按哪个执行。两个参数都有默认值，因此` cin.ignore() `就等效于` cin.ignore(1, EOF)`， 即跳过一个字符。
>
>它的一个常用功能就是用来清除以回车结束的输入缓冲区的内容，消除上一次输入对下一次输入的影响。
>
>使用 **`getline(cin，str)`**往往可以实现更加简单以及安全的字符串操作
>
>```cpp
>#include <iostream>
>#include <string>
>
>using namespace std;
>
>int main()
>{
>  int ival1 = 0, ival2 = 0;
>  std::cin >> ival1;
>  /std::cin.ignore(100, '\n');
>  std::cin >> ival2;
>  std::cout << "ival1 = " << ival1 << std::endl;
>  std::cout << "ival2 = " << ival2 << std::endl;
>
>  return 0;
>}
>
>// 加入cin.ignore(100,'\n')的结果
>winston@Winstonly-Ly:/media/winston/本地磁盘/Job/TestProject/Debug$ ./strace
>32 23
>234 534
>ival1 = 32
>ival2 = 234
>
>// 不加入cin.ignore(100,'\n')的结果
>winston@Winstonly-Ly:/media/winston/本地磁盘/Job/TestProject/Debug$ ./strace
>324 4234
>ival1 = 324
>ival2 = 4234
>```
>
>

### 1.9 Lambda 表达式

对于只使用一次的函数对象类，利用 **Lambda** 表达式在直接使用该对象的地方进行定义，Lambda 表达式可以减少程序中函数对象类的数量

**Lambda 表达式的定义形式如下**：

```cpp
[外部变量访问方式说明符](参数表)->返回值类型
{
	语句块
}

/* 外部变量访问方式说明符：可以是 = 或 &，表示{}中用到的、定义在{}外面的变量是否允许被改变，= 表示不允许，& 表示允许 */
例如：
#include <iostream>
#include <algorithm>
using namespace std;
int main()
{
    int a[4] = { 1, 2, 3, 4 };
    int total = 0;
    for_each(a, a + 4, [&](int & x) { total += x; x *= 2; });
    cout << total << endl;  //输出 10
    for_each(a, a + 4, [=](int x) { cout << x << " "; });
    return 0;
}
输出结果：
10
2 4 6 8
```

### 1.10 `auto` 和 `decltype` 关键字

用`auto`关键字定义变量，编译器会自动判断变量的类型

```cpp
auto i = 0; 	/* i 是 int */
auto p = new A();		/* p 是 A* */
```

`decltype`关键字可以用于求表达式的类型

```cpp
int i;
double t;
struct A {double x};
const A* a = new A();
decltype(a) x1;		/* x1 是 A* */
decltype(i) x2;		/* x2 是 int */
decltype(a->x) x3;	/* x3 是 double */
```

#### 1.11 static 的作用

- 全局静态变量：在静态存储区，在整个程序运行期间一直存在，但**只在声明它的文件内可见**
- 局部静态变量：当语句或者函数结束的时候，作用域结束，但**不会被销毁**，留在内存中，只有下次调用函数才能被访问，并且值不变
- 静态函数：**静态函数只在声明它的文件内可见**，其他文件不可见；不要在头文件中声明static的全局函数，不要在cpp内声明非static的全局函数
- 类的静态成员：静态成员是类的**所有对象中共享的成员**，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用
- 类的静态函数：和静态成员一样，属于类的静态成员，它们都不是对象成员；静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员

## 二 顺序容器详解

### 2.1 头文件

```cpp
#include <vector>
#include <list>
#include <depue>
```

所有容器类型都定义了默认构造函数，用于创建空容器对象，默认构造函数不带参数。

命名限定： `using std::vector;`或`using namespace std;`

### 2.2 容器元素的初始化

| 构造函数     | 描述                                                         |
| ------------ | ------------------------------------------------------------ |
| C<T> c;      | 创建一个名为 c 的空容器。C 是容器类型名，如 vector，T 是元素类型，如 int 或 string 适用于所有容器。 |
| C<T>  c(c2); | 创建容器 c2 的副本 c；c 和 c2 必须具有相同的容器类型，并存放相同类型的元素。适用于所有容器。 |
| C<T> c(b,e); | 创建 c，其元素是迭代器 b 和 e 标示的范围内元素的副本。适用于所有容器。 |
| C<T> c(n,t); | 用 n 个值为 t 的元素创建容器 c，其中值 t 必须是容器类型 C 的元素类型的值，或者是可转换为该类型的值。只适用于顺序容器 |
| C<T> c(n);   | 创建有 n 个值初始化（第 3.3.1 节）（value-initialized）元素的容器 c。只适合顺序容器 |

```cpp
/* 将一个容器初始化为另一个容器的副本（容器类型和元素类型都必须相同） */
vector<int> iVec;
vector<int> iVec2(iVec);

/* 初始化一段元素的副本(利用迭代器标记要复制的元素范围) */
lsit <string> sList(sVec.begin(), sVec.end());

/* 分配和初始化指定数目的元素 */
vector<int> iVec(10,5);
vector<int> iVec1(10);
```

- 支持复制和赋值功能是容器元素类型的最低要求
- 容器元素都是副本

### 2.3  容器的关系运算符

进行比较的容器必须具有相同的容器类型，并且其元素类型也要相同。所有容器都是通过比较其元素来实现关系运算。

- 如果两个容器具有相同的长度而且所有元素都相等， 那么这两个容器就相
  等；否则，它们就不相等。
- 如果两个容器的长度不相同， 但较短的容器中所有元素都等于较长容器中
  对应的元素，则称较短的容器小于另一个容器。
-  如果两个容器都不是对文的初始子序列， 则它们的比较结果取决于所比较
  的第一个不相等的元素。

### 2.4 基本操作

```cpp
// 增添元素
/* 在容器尾部插入一个elem数据 */
c.push_back(elem);

/* 在容器开始处插入一个elem元素 */
c.push_front(elem);

/* 在指定位置插入元素，返回指向新元素的迭代器 */
c.insert(p, t);  // 在迭代器p所指向的元素前面插入值为t的新元素
c.insert(p, n, t); // 迭代器p所指向的元素前面插入n个值为t的新元素
c.insert(p,b,e); // 在迭代器 p 所指向的元素前面插入由迭代器 b 和 e 标记的范围内的元素

// 删除元素
/* 删除容器末尾的数据，返回void */
c.pop_back();

/* 删除容器c的第一个元素返回void,vector不支持*/
c.pop_front();

/* 删除迭代器p所指向的元素，返回一个迭代器，它指向被删除元素后面的元素 */
c.erase(p);

/* 删除容器c的所有元素，返回void */
c.clear();

// 迭代器（左闭右开）
/* 返回一个迭代器，指向容器c的第一个元素 */
c.begin();

/* 返回一个迭代器，指向容器c的最后一个元素的下一位置 */
c.end();

// 容器大小
/* 返回容器c中的元素个数，返回类型为c::size_type */
c.size();

/* 返回容器 c 可容纳的最多元素个数，返回类型为c::size_type */
c.max_size();

/* 返回标记容器大小是否为 0 的布尔值 */
c.empty();

/* 调整容器c的长度大小，使其能容纳n个元素，如果n<c.size()，则删除多出来的元素；否则，添加采用值初始化的新元素 */
c.resize(n);

// 容器容量
// size 指容器当前拥有的元素个数；而 capacity 则指容器在必须分配新存储空间之前可以存储的元素总数。
// 每当 vector 容器不得不分配新的存储空间时，以加倍当前容量的分配策略实现重新分配。
/* 返回容器容量大小，一般翻倍增长 */
c.capacity();

/* 提前设置容量大小，预留额外的存储空间 */
c.reserve(n)；

// 遍历元素
/* 使用迭代器访问元素 */
vector<int>::iterator it;
for(it=vec.begin();it!=vec.end();it++)
    cout<<*it<<endl;
    
// 使用下标遍历元素
for(int i = 0; i < vec.size(); ++i)
{
	cout << vec[i] << endl;
}
```

### 2.5 访问成员函数

```cpp
/* 返回容器 c 的最后一个元素的引用。如果 c 为空，则该操作未定义 */
c.back();

/* 返回容器 c 的第一个元素的引用。如果 c 为空，则该操作未定义 */
c.front();

/* 返回下标为n的元素引用，只适用于 vector 和 deque 容器 */
c[n]

/* 返回下标为n的元素的引用，只适用于vector和deque容器 */
c.at(n)
// 利用下标操作的时候必须确认该下标处元素必须存在
```

### 2.6 复制操作

```cpp
/* 删除容器 c1 的所有元素， 然后将 c2 的元素复制给 c1。 c1 和c2 的类型（包括容器类型和元素类型）必须相同 */
c1 = c2

/*交换内容：调用完该函数后，c1 中存放的是 c2 原来的元素，c2 中存放的则是 c1 原来的元素。c1 和 c2 的类型必须相同 */
c1.swap(c2)

/* 重新设置 c 的元素：将迭代器 b 和 e 标记的范围内所有的元素复制到 c 中。b 和 e 必须不是指向 c 中元素的迭代器 */
c.assign(b, e)

/* 将容器 c 重新设置为存储 n 个值为 t 的元素 */
c.assign(n, t)
// 带有一对迭代器参数的 assign 操作允许我们将一个容器的元素赋给另一个不同类型的容器。

```

## 三 标准库string类型

库文件：`#include <string>`

string 类型支持长度可变的字符串，C++ 标准库将负责管理与存储字符相关的内存，以及提供各种有用的操作。

### 3.1 string对象的初始化

```cpp
// 默认构造函数s1为空串
string s1；
// 将s2初始化为s1的一个副本
string s2(s1);
// 将s3初始化为一个字符串字面值副本
string s3("value");
// 将s4初始化为字符'c'的n个副本
string s4(n, 'c');

// string 类没有接收一个整型参数或一个字符型参数的构造函数。
```

### 3.2 string对象的读写

- 可用标准输入输出操作符来读写`string`对象 

  ```shell
  string s;
  cin >> s;
  cout << s << endl;
  // 读取并忽略开头所有的空白字符（如空格、换行符、制表符）
  // 读取字符至再次遇到空白字符
  ```

- 使用`getline`读取整行文本

  `getline`接受两个参数：一个输入流对象、一个string对象

  `getline`从输入流的下一行读取，并保存读取的内容到不包括换行符，只要遇到换行符就停止读入。

### 3.3 string对象的操作

```cpp
// 如果s为空串，返回true，否则返回false
s.empty()
// 返回s中字符的个数
s.size()
// 返回s中位置为n的字符，位置从0开始计数
s[n]
// 把s1和s2连接成一个新字符串，返回生成的字符串，加法表示连接
// 使用连接操作时，+ 操作符的左右操作数至少有一个是string类型的
s1 + s2
// 把s1内容替换为s2的副本
s1 = s2
// 比较v1和v2的内容，相等则返回true，否则返回false
v1 == v2
// 保持惯有含义的操作符
!=, <, <=, >, >=
// 如果两个 string 对象长度不同， 且短的 string 对象与长的 string 对象的前面部分相匹配，则短的 string 对象小于长的 string 对象。
// 如果 string 对象的字符不同，则比较第一个不匹配的字符。

// 可以用 char* 类型的变量、常量，以及 char 类型的变量、常量对 string 对象进行赋值
string s1；
s1 = "hello";   // s1 = "hello"
s2 = 'K';		// s2 = "K";

// 求 string 对象的子串
string substr(int n = 0, int m = string:npos) const;
# 从下标 n 开始，直到 m 个字符就是求得的子串

// 交换两个 string 对象的内容
swap 成员函数可以交换两个 string 对象的内容
string s1("West”), s2("East");
s1.swap(s2);  // s1 = "East"，s2 = "West"

// 取字符串的首地址，但这只是临时的地址，一旦string对象改变，地址也会变化
string str;
char *p = str.c_str();
```

### 3.4 string对象中字符的处理

头文件：`#include <cctype>`

| 函数           | 描述                                                    |
| -------------- | ------------------------------------------------------- |
| `isalnum(c)`   | 如果 c 是字母或数字，则为 True。                        |
| `isalpha(c) `  | 如果 c 是字母，则为 true。                              |
| `iscntrl(c)`   | 如果 c 是控制字符，则为 true                            |
| `isdigit(c)`   | 如果 c 是数字，则为 true。                              |
| `isgraph(c)`   | 如果 c 不是空格，但可打印，则为 true。                  |
| `islower(c) `  | 如果 c 是小写字母，则为 true。                          |
| `isprint(c)`   | 如果 c 是可打印的字符，则为 true。                      |
| `ispunct(c)`   | 如果 c 是标点符号，则 true。                            |
| `isspace(c)`   | 如果 c 是空白字符，则为 true。                          |
| `isupper(c) `  | 如果 c 是大写字母，则 true。                            |
| `isxdigit(c) ` | 如果是 c 十六进制数，则为 true。                        |
| `tolower(c) `  | 如果 c 大写字母，返回其小写字母形式，否则直接返回 c。   |
| `toupper(c)`   | 如果 c 是小写字母，则返回其大写字母形式，否则直接返回 c |

### 3.5 C风格字符串

字符串字面值的类型就是`const char `类型的数组。

C风格字符串是以空字符NULL结束的字符数组。

一系列标准库函数：`#include "string.h"`

| 函数               | 描述                                                         |
| ------------------ | ------------------------------------------------------------ |
| `strlen(s) `       | 返回 s 的长度，不包括字符串结束符 null                       |
| `strcmp(s1, s2)`   | 比较两个字符串 `s1 `和` s2 `是否相同。若 `s1 `与` s2` 相等，返回 0；若` s1 `大于` s2`，返回正数；若` s1` 小于` s2`，则返回负数 |
| `strcat(s1, s2)`   | 将字符串` s2 `连接到 `s1`后，并返回 `s1`                     |
| `strcpy(s1, s2)`   | 将 `s2 `复制给` s1`，并返回 `s1`                             |
| `strncat(s1,s2,n)` | 将` s2 `的前 n 个字符连接到 `s1 `后面，并返回` s1`           |
| `strncpy(s1,s2,n)` | 将` s2` 的前 n 个字符复制给` s1`，并返回` s1`                |

**C风格字符串必须以空字符NULL结束，使用时要注意预留足够的存储空间**

## 四 数组和指针

### 4.1 数组

数组是由类型名,标识符和维数组成的复合数据类型

#### 4.1.1 数组的定义和初始化

- 显式初始化数组元素:为其元素提供一组用逗号分隔的初值,这些初值用`{}`括起来,显式初始化的数组不需要指定数组的维数值

  ```cpp
  const unsigned array_size = 3;
  int ia[array_size] = {0, 1, 2};
  ```

- 未显式提供元素初值

  - 在函数体外定义的内置数组，其元素均初始化为 0。
  - 在函数体内定义的内置数组，其元素无初始化。
  -  不管数组在哪里定义，如果其元素为类类型，则自动调用该类的默认构造函数进行初始化；如果该类没有默认构造函数，则必须为该数组的元素提供显式初始化。

- 特殊的字符数组

  字符数组既可以用一组花括号括起来,逗号隔开的字符字面值进行初始化,也可以用一个字符串字面值进行初始化

  ```cpp
  char a1[] = {'C', '+', '+'}; // size 为 3
  // 使用一组字符串字面值初始化字符数组时,注意记得添加结束字符串的空字符
  ```

#### 4.1.2 数组操作

数组元素可用下标操作来访问

- 使用数组时,必须确保其下标值在正确范围内,防止数组越界
- 导致安全问题的最常见原因是"缓冲区溢出"错误

### 4.2 指针

指针是指向某种类型对象的复合数据类型,指针是一个对象,指向另一个对象,它的值是所指对象的地址.

#### 4.2.1 指针的定义和初始化

C++使用`*`把一个标识符声明为指针,对指针初始化或赋值时必须保证类型匹配

- **一个有效的指针必然是一下三种状态之一**
  - 保存一个特定对象的地址
  - 指向某个对象后面的另一对象
  - 是 0 值,若指针保存 0 值,表明指针为空,不指向任何对象

- **对指针初始化或赋值只能使用以下五种类型的值**

  - 0 值常量表达式,例如在编译时可获得 0 值的整型 `const` 对象或字面值常量 0 
  - 类型匹配的对象的地址
  - 另一对象末的下一地址
  - 同类型的另一个有效指针

  - 预处理器变量NULL,在头文件`cstdlib`中定义

- **void指针**

  用来保存任何类型对象的地址

#### 4.2.2 指针操作

对指针进行解引用可访问它所指的对象,`*`操作符将获取指针所指的对象

- **给指针赋值或通过指针进行赋值**

  - 修改指针本身的值: 改变指针所值对象
  - 用解引用操作进行赋值: 修改指针所指对象的值

- **指针和引用**

  引用总是指向某个对象;定义引用时必须进行初始化

  给引用赋值修改的是该引用所关联对象的值,而一经初始化,引用就始终只指向同一个特定对象

- **指向指针的指针**

  指针的存储地址可存放在指针中

  ```c++
  int ival = 1;
  int *pi = &ival;
  int **ppi = &pi;
  ```

#### 4.2.3 指针访问数组元素c++

在表达式中使用数组名时,该名字会自动转换为指向数组的第一个元素的指针

```c++
int a[10];
int *p = a;
int *p = &a[0];
// 用取地址操作符 & 获取该元素的存储地址
```

- **指针的算数操作**

  在指针上加上（或减去）一个整型数值 n 等效于获得一个新指针，该新指针指向指针原来指向的元素之后（或之前）的第 n 个元素。

- C++允许计算数组或对象的超出末端的地址,但是不能进行解引用操作

- 输出数组元素

  ```c++
  for (int *pbegin = int_arr, *pend = int_arr + arr_sz;pbegin != pend; ++pbegin)
  	cout << *pbegin << ' '; 
  	
  // 只要定义的多个变量具有相同的类型,就可以在for循环的初始化语句中同时定义它们
  ```

- 指针是数组的迭代器

#### 4.2.4 指针和 `const` 限定符

指向`const`对象的指针和 `const` 指针

- **指向 `const` 对象的指针**

  指针指向 `const` 对象,则不允许用指针来改变其所指的`const`值

  C++强制要求指向`const`对象的指针也必须具有`const`特性

  ```c++
  const int *cptr;      // cptr本身并不是const,但不能通过cptr修改其所指对象的值
  *cptr = 42;       	  // error
  ```

  允许把非`const`对象的地址赋给指向`const`对象的指针,可以通过其他方式修改非`const`对象的值

  ```c++
  int val = 3;
  cptr = &val;
  ```

  指向`const`的指针常用作函数的形参

- `const`指针

  `const`指针,本身的值不能修改,不能使得其指向其他对象.同样`const`指针也必须在定义时初始化

  ```c++
  int errNum = 1;
  int *const curErr = &errNum;
  ```

  指针所指对象的值能否修改完全取决于该对象的类型

- 指向`const`对象的`const`指针

  ```c++
  int a = 3;
  const int *const ptr = &a;
  
  // 既不能修改所指对象的值,也不能修改该指针的指向
  ```

### 4.3 动态数组

每个程序在执行都占用一块可用的内存空间,用于存放动态分配的对象,此空间称为程序的自由存储区或者**堆**。

C 语言使用`malloc`和`free`在堆中分配和释放内存，C++使用`new`和`delete`在堆中分配和释放内存。

#### 4.3.1 动态数组的定义

动态分配数组时，只需要指定类型和数组长度，不必为数组对象命名

```c++
// new 表达式返回指向新分配数组的第一个元素的指针，程序通过地址间接访问堆中对象
// new 表达式需要指定指针类型以及在方括号中给出数组维数，该维数可以是任意的复杂表达式
int *pia = new int(10);		// pia = 10
int *p = new int[10];		// p 是一个数组，数组由 10 个 int 型组成
```

#### 4.3.2 初始化动态分配的数组

如果数组元素具有类类型，就使用该类的默认构造函数实现初始化

如果数组元素是内置类型，则无初始化

在堆中创建的数组存储了内置类型的`const`对象，则必须为这个数组提供初始化

#### 4.3.3 动态空间的释放

C++为指针提供`delete []`表达式释放指针所指向的数组空间

```C++
delete p;			// 删除变量
delete []pia；		// 删除数组
```

#### 4.4.4 使用数组初始化`vector`对象

使用数组初始化 vector 对象， 必须指出用于初始化式的第一个元素以及数组最后一个元素的下一位置的地址

```c++
const sizt_t arr_size = 6;
int iArr[arr_size] = {0, 1, 2, 3, 4, 5};
vector<int> iVec(iArr, iArr + arr_size);
```

#### 4.4.5 指针和多维数组

[对于数组指针和指针数组的理解及其应用](https://blog.csdn.net/weixin_44781107/article/details/90407979)

多维数组就是数组的数组，可以使用由花括号括起来的初始化式列表来初始化多维数组的元素。

多维数组转换而成的指针类型应是指向第一个内层数组的指针

- 指针数组

  指针的数组，首先变量是一个数组，其次指针修饰这个数组，这个数组中的所有元素都是指针类型

  ```c++
  char *arr[4] = {"hello", "world", "C++", "!!!"};
  // arr是一个栈区，有四个元素的数组，每个元素又是一个指针，每个元素各占四个字节，arr+1会跳过四个字节
  ```

  指针数组常用在主函数传参

  `int main(int argc, char *argv[])`

  不能传递整个数组过去，应该传递数组的首地址，用一个指针接受这个地址，指针数组对应着二级指针

  `void fun(char **pp); 	// 子函数中的形参`

  `fun(char *p[]); 	// 主函数中的实参`

- 数组指针

  数组的指针，这个指针存放着一个数组的首地址，这个指针指向一个数组的首地址

  ```c++
  char (*pa)[4];
  // pa是一个指针，指向一个char[4]的数组，每个数组元素是一个char类型的变量
  ```

  数组指针对应着二维数组

  ```C++
  void fun(int (*p)[4]);		// 子函数中的形参，数组指针
  a[3][4] = {0};		// 主函数中定义的二维数组
  fun(a);		// 主函数中调用子函数的实参，是二维数组的首元素首地址
  // a可以理解为指向第一个元素的指针，a[0] = p,a[1] = p + 1...
  // *a可以理解为指向第一个数组中首元素的指针，所以**a = a[0][0]
  // *(*(a+i)+j) = a[i][j]
  // sizeof()用于变量时返回这个变量占用的实际空间的大小，当sizeof用于数组名时，返回整个数组的大小（这里的大小指占用的字节数，用于指针的时候返回变量占用字节的大小
  ```


## 五 类和数据抽象

类就是定义了一个新的数据类型和一个新作用域。用关键字`class`来定义

### 5.1 类成员

数据、函数或类型别名；==public，private，protected==

```C++
class 类名{
public:
	// 公有成员：程序中类的外部是可访问的
private：
	// 私有成员：在类的外部是不可访问的，甚至不可查看
protected:
	// 受保护成员：在派生类（子类）中是可访问的，其他类外不可访问
};
```

>- **public 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
>- **protected 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
>- **private 继承：**基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private

==**类只是一个模板（Template），编译后不占用内存空间，所以在定义类时不能对成员变量进行初始化，因为没有地方存储数据。只有在创建对象以后才会给成员变量分配内存，这个时候就可以赋值了**==

### 5.2 构造函数

- 一个特殊的、与类名相同的成员函数，会在每次创建类的新对象时执行。用于给某些数据成员设置合适的初值。

- 编译器创建的默认构造函数通常称为默认构造函数， 它将依据如同变量初始化的规则初始化类中所有成员。

- 构造函数的名字与类的名字相同，并且不能指定返回类型。像其他任何函数一样，它们可以没有形参，也可以定义多个形参。 
- 构造函数不能声明为`const`

**构造函数可以被重载**

- 可以为一个类声明的构造函数的数量没有限制，只要每个构造函数的形参表是唯一的。一般而言，不同的构造函数允许用户指定不同的方式来初始化数据成员。

- 实参决定使用哪个构造函数

**构造函数和初始化列表**

在冒号和花括号之间的代码称为构造函数的初始化列表。为类的一个或多个数据成员指定初值。

```shell
Line::Line( double a, double b, double c): X(a), Y(b), Z(c)
{
  ....
}
```

上面的语法等效于如下语法(显式初始化)：

```shell
Line::Line(double a, double b, double c)
{
	X = a;
	Y = b;
	Z = c;
	....
}
```

### 5.3 数据抽象和封装

类背后的基本思想是数据抽象和封装

数据抽象是一种依赖于接口和实现分离的编程（和设计）技术。

封装是一项低层次的元素组合起来的形成新的、高层次实体的技术。

C++使用访问标号(public,private,protected)来定义类的抽象借口和实施封装：

- 程序的所有部分都可以访问带有 public 标号的成员。 类型的数据抽象视图由其 public 成员定义。
- 使用类的代码不可以访问带有 private 标号的成员。private 封装了类型的实

如果类是用`struc `关键字定义的，则在第一个访问标号之前的成员是公有的；如果类是用class 关键字是定义的，则这些成员是私有的。

### 5.4 内联函数

在一个函数名定义前面加关键字`inline`。即可定义内联函数，但是必须在第一次调用函数之前进行定义。

内联函数在编译的时候，编译器会把该函数的副本**复制到**调用该函数的地方，而其他函数实在运行时进行替换的。

在类定义中的定义的函数都是内联函数，即使没有关键字`inline`。

**关键字inline 必须与函数定义体放在一起才能使函数成为内联，仅将inline 放在函数声明前面不起任何作用**。

**内联函数可避免频繁调用小函数对栈内存重复开辟所带来的消耗，从而提高函数的执行效率，但会消耗更多的内存空间**

**使用内联函数的注意事项**

- 在内联函数内不允许使用循环语句和开关语句；
- 内联函数的定义必须出现在内联函数第一次调用之前；
- 类结构中所在的类说明内部定义的函数是内联函数。

### 5.5 类的声明和定义

类的定义以分号结束，在类定义之后可以接一个对象定义列表。

```c++
class Sales_item { /* ... */ };
class Sales_item { /* ... */ } accum, trans;

Sales_item s1;			/* 栈上创建对象 */
Sales_item* s2 = new Sale_item;		/* 堆上创建对象，使用 new 在堆上创建出来的对象是匿名的，没法直接使												   用，必须要用一个指针指向它，再借助指针来访问它的成员变量或成员函数 */
```

可以声明一个类而不定义它：

```c++
class Screen; 		// 前向声明

// 不完全类型，只能用于定义指向该类型的指针及引用，或者用于声明使用该类型作为形参类型或者返回类型的函数
```

**类对象**

==定义一个类时，也就是定义一个类型，并不进行存储分配。==

==定义一个类的对象的时候，才进行存储分配==

**定义类类型的对象**

定义一个类类型之后，按以下两种方式使用：

- 将类的名字直接用作类型名。
- 指定关键字` class` 或 `struct`，后面跟着类的名字：

### 5.6 隐含的 this 指针

成员函数具有一个附加的隐含形参，即指向该类对象的一个指针，称为`this`指针，与调用成员函数的对象绑定在一起。

```c++
std::string isbn() const 
{ 
	return this->bookNo; 
}
```

每个对象都能通过`this`指针来访问自己的地址。

友元函数没有`this`指针，因为友元函数不是类的成员。

`this`指针不能再静态函数中使用。

`this`指针是一个常量指针，不允许改变`this`中保存的地址。

**返回`*this`**

```c++
Screen& Screen::set(char c)
{
	contents[cursor] = c;
	return *this;
}
```

### 5.7 类作用域

每个类都定义了自己的新作用域和唯一的类型。在类的定义体内声明类成员，将成员名引入类的作用域。

**使用类成员**

在类作用域之外，成员只能通过对象或指针分别使用成员访问操作符`.`或`->`来访问。

```c++
Class obj；
Class *ptr = &obj；
prt->member;
obj.member;
```

一些成员使用成员访问操作符来访问，另一些直接通过类使用作用域操作符`::`来访问。

出现在类的定义体之外的成员定义必须指明成员出现在哪个类中：

```c++
double Sales_item::avg_price() const
{
	if (units_sold)
		return revenue/units_sold;
	else
		return 0;
}
```

当看到返回类型时，其名字是在类作用域之外使用。必须用完全限定的类型名 `Screen::index` 来指定所需要的` index `是在类` Screen `中定义的名字

```c++
class Screen {
public:
	typedef std::string::size_type index;
	index get_cursor() const;
};
# 在类定义体之外定义get_cursor()
inline Screen::index Screen::get_cursor() const
{
	return cursor;
}
```

### 5.8 友元函数

- 友元机制允许一个类对其非公有成员的访问权授予指定的函数或类。
- 友元函数的声明以关键字`friend`开始。只能出现在类定义的内部，定义在类的外部。
- 友元可以是普通的非成员函数， 或前面定义的其他类的成员函数， 或整个类。

```c++
class Box
{
   double width;
public:
   double length;
   friend void printWidth( Box box );
   void setWidth( double wid );
};
```

### 5.9 `static`类成员

- 可以用`static`关键字将类成员变量定义为静态变量

- ==`static`成员是与类关联的对象，并不与该类的对象相关联，静态成员在类的所有对象中是共享的==

- 可以通过作用域操作符从类直接调用 static 成员，或者通过对象、引用或指向该类类型对象的指针间接调用

- 静态成员的定义应在类的外部进行，利用作用域操作符`：：`来声明静态变量并初始化，这是在给其分配内存

  ```c++
  class Box{
  public:
  	static int a;
  	// 其他公有成员
  private:
  	// 私有成员
  }；
  int Box::a = 0;
  ```

  **静态成员函数**

  - 静态成员函数使用类名加`::`就可以访问
  - 静态成员函数只能访问静态成员数据，其他静态成员函数或类外部的其它函数
  - 静态成员函数无this指针，即使对象不存在也可访问

### 5.10 析构函数

- 析构函数的用途是自动获取资源，在撤销类对象时会自动调用析构函数
- 当对象超出作用域或动态分配的对象被删除时，将自动应用析构函数
- 编译器会自动合成一个析构函数，按照对象创建时的逆序撤销每个非静态成员
- 在类名前面加`~`构成析构函数，无返回值，无形参

### 5.11 拷贝构造函数

[C++中构造函数、拷贝构造函数和赋值函数的区别与实现](https://blog.csdn.net/zcyzsy/article/details/52132936?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)

只有单个形参，并且该形参是对本类类型对象的引用（常用`const`修饰），这样的构造函数称为**拷贝构造函数**

> 拷贝构造函数和赋值：
>
> **拷贝构造函数是一个对象初始化一块内存区域，这块内存就是新对象的内存区，而赋值函数是对于一个已经被初始化的对象来进行赋值操作**

- 对象的定义形式：直接初始化和拷贝初始化

  >- 拷贝初始化使用`=`符号，直接初始化直接将初始化式放在圆括号中
  >
  >- 直接初始化直接调用与实参匹配的构造函数，拷贝初始化总是调用拷贝构造函数（先创建临时对象，再将临时对象的副本拷贝给正在创建的对象）

- 拷贝构造函数通常用于一下情况：

  >- 一个对象以值传递的方式传入函数参数
  >- 一个对象以值传递的方式从函数返回
  >- 一个对象需要通过另外一个对象进行初始化。

- **合成拷贝构造函数**

  合成复制构造函数的行为是，执行逐个成员（现在对象的每个非static成员）初始化，将新对象初始化为原对象的副本

>**浅拷贝与深拷贝**
>
>**浅拷贝**：如果复制的对象中引用了一个外部内容（例如分配在堆上的数据），那么在复制这个对象的时候，让新旧两个对象指向同一个外部内容，就是浅拷贝。（指针虽然复制了，但所指向的空间内容并没有复制，而是由两个对象共用，两个对象不独立，删除空间存在）
>
>**深拷贝**：深拷贝：如果在复制这个对象的时候为新对象制作了外部对象的独立复制，就是深拷贝

>- 对象不存在，且没用别的对象来初始化，就是调用构造函数
>
>- 对象不存在，且用别的对象来初始化，就是调用拷贝构造函数
>
>- 对象存在，且用别的对象来给它赋值，就是赋值函数

## 六 重载运算符和重载函数

C++ 允许在同一作用域中的某个**函数**和**运算符**指定多个定义，分别称为**函数重载**和**运算符重载**。

重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。通过比较参数类型来确定使用最合适的定义。

**类重载、覆盖、重定义之间的区别**

- **重载**指的是**函数具有的不同的参数列表，而函数名相同的函数**。重载要求参数列表必须不同，比如参数的类型不同、参数的个数不同、参数的顺序不同。（发生在同一个类中）
- **覆盖**是存在类中，**子类重写从基类继承过来的函数**。==被重写的函数不能是static的。必须是virtual的==。但是函数名、返回值、参数列表都必须和基类相同（发生在基类和子类）
- **重定义**也叫做**隐藏**，**子类重新定义父类中有相同名称的非虚函数** ( 参数列表可以不同 ) 。（发生在基类和子类）

### 6.1 函数重载

在同一个作用域中，可声明几个功能类似的同名函数，但是这些同名函数的形式参数（参数个数，类型或者顺序）必须不同。不能仅通过返回类型的不同来重载函数。

```c++
class PrintData
{
public:
	void print(int i)
    {
    
    }
	void print(couble i)
	{
	
	}
}
```

**函数匹配**：将函数调用与重载函数集合中的一个函数相关联的过程，通过自动提取函数调用中实际使用的实参与重载集合中各个函数提供的形参作比较。

**重载确定的三个步骤**：

- 候选函数：调用重载函数集合
- 选择可行函数：形参个数相同，实参类型与形参类型匹配
- 寻找最佳匹配：

### 6.2 运算符重载

重载的运算符是带有特殊名称的函数，函数名由关键字`operator`和要重载的运算符符号构成的。

```c++
Student operator+(const Student&, const Student&);
```

- **重载操作符必须具有一个类类型操作数**

  >用于内置类型的操作符，其含义不能变
  >
  >重载操作符必须具有至少一个类类型或枚举类型的操作数

- 大多数重载操作符可以定义为普通非成员函数或类的成员函数

  作为类成员的重载函数，其形参比操作数数目少 1 ，隐含 `this`指针的存在

- 操作符定义为非成员函数时，必须将其设置为操作类的友元

- 注意：

  - 运算重载符不可以改变语法结构。
  - 运算重载符不可以改变操作数的个数。
  - 运算重载符不可以改变优先级。
  - 运算重载符不可以改变结合性。

#### 6.2.1 一元运算符重载

- **递增运算符(++)和递减运算符(--)**

  因为自增自减操作符改变操作对象的状态，一般将其作为成员。

  返回被增量或减量对象的引用。

  ```c++
  // 前缀式操作
  Student& operator++();
  Student& operator--();
  // 后缀式操作：接收一个额外的无用的int型形参
  // 在进行增减操作时必须声明一个当前状态的副本
  Student& operator++(int);
  Student& operator--(int);
  ```

  ```c++
  // 重载前缀递增运算符（ ++ ）
    	  Time operator++ ()  
        {
           ++minutes;          // 对象加 1
           if(minutes >= 60)  
           {
              ++hours;
              minutes -= 60;
           }
           return Time(hours, minutes);
        }
  // 重载后缀递增运算符（ ++ ）
        Time operator++( int )         
        {
           // 保存原始值
           Time T(hours, minutes);
           // 对象加 1
           ++minutes;                    
           if(minutes >= 60)
           {
              ++hours;
              minutes -= 60;
           }
           // 返回旧的原始值
           return T; 
  ```

  

- **一元运算符(-)**

- **逻辑非运算符(!**)

#### 6.2.2 二元运算符重载

加运算符（ + ）、减运算符（ - ）、乘运算符（ * ）和除运算符（ / ）都属于二元运算符

注意， 为了与内置操作符保持一致， 加法返回一个右值，而不是一个引用。

```c++
// 重载 + 运算符，用于把两个 Box 对象相加
Box operator+(const Box& b)
   {
      Box box;
      box.length = this->length + b.length;
      box.breadth = this->breadth + b.breadth;
      box.height = this->height + b.height;
      return box;
   }
```

#### 6.2.3 关系运算符重载

关系运算符（ < 、 > 、 <= 、 >= 、 == 等等），它们可用于比较 C++ 内置的数据类型。

可以重载任何一个关系运算符，重载后的关系运算符可用于比较类的对象。

通常，C++ 中的类使用相等操作符表示对象是等价的。即，它们通常比较每个数据成员，如果所有对应成员都相同，则认为两个对象相等。

```c++
 // 重载小于运算符（ < ）
      bool operator <(const Distance& d)
      {
         if(feet < d.feet)
         {
            return true;
         }
         if(feet == d.feet && inches < d.inches)
         {
            return true;
         }
         return false;
      }
```



#### 6.2.4 赋值运算符重载

类赋值操作符接受类类型形参，通常，该形参是对类类型的` const` 引用，但也可以是类类型或对类类型的非 `const `引用。
赋值操作符可以重载。无论形参为何种类型，赋值操作符必须定义为成员函数，这一点与复合赋值操作符有所不同。

赋值必须返回对 `*this`的引用



#### 6.2.5 输入/输出运算符重载

为了与 IO 标准库一致，操作符应接受 `ostream& `作为第一个形参，对类类型 `const `对象的引用作为第二个形参，并返回对`ostream `形参的引用。

输入操作符的第二个形参是对要读入的对象的**非`const`**引用。

IO操作符的重载必须为非成员函数**,需要把运算符重载函数声明为类的友元函数，这样我们就能不用创建对象而直接调用函数**。

```c++
friend ostream &operator<<( ostream &output, const Distance &D )
{ 
     output << "F : " << D.feet << " I : " << D.inches;
     return output;            
}
 
friend istream &operator>>( istream  &input, Distance &D )
{ 
     input >> D.feet >> D.inches;
     return input;            
}
```



#### 6.2.6 函数调用符()重载

函数调用操作符必须声明为成员函数。一个类可以定义函数调用操作符的多个版本，由形参的数目或类型加以区别。

定义了调用操作符的类，其对象称为函数对象。函数对象经常用作通用算法的实参。

```c++
Distance operator()(int a, int b, int c)
{
	Distance D;
    // 进行随机计算
    D.feet = a + c + 10;
    D.inches = b + c + 100 ;
    return D;
}

Distance D1， D2；
......
D2 = D1(1, 2, 3);
```

#### 6.2.7 下标操作符重载

可以从容器中检索单个元素的容器类一般会定义下标操作符，即`operator[]`。

下表操作符必须定义为类成员函数。

类定义下标操作符时，一般需要定义两个版本：一个为非 `const `成员并返回引用，另一个为` const `成员并返
回 `const` 引用。

```c++
int& operator[](int i)
{
...
}
```

#### 6.2.8 成员访问操作符重载

成员访问操作符必须定义为类成员函数，解引用操作不要求定义为成员。

成员访问操作符必须返回指向类类型的指针或者类的对象

```c++
class Ptr{
   //...
   X * operator->();
};
// 类 Ptr 的对象可用于访问类 X 的成员，使用方式与指针的用法十分相似。例如：
void f(Ptr p )
{
   p->m = 10 ; // (p.operator->())->m = 10
}
```

### 6.3 转换与类类型

可以定义转换操作符，给定类类型的对象，该操作符将产生其他类型的对象。 

转换操作符是一种特殊的类成员函数。它定义将类类型值转变为其他类型值的转换。转换操作符在类定义体内声明，在保留字 operator 之后跟着转换的目标类型：

```c++
operator int() const { return cal;}
```

转换函数采用以下形式：

`operator type()c++`

`type` 表示内置类型名、类类型名或由类型别名定义的名字。

不允许转换为数组或函数类型，转换为指针类型（数据和函数指针）以及引用类型是可以的。

转换函数必须是成员函数，不能指定返回类型，并且形参表必须为空。

## 七 面对对象编程

**面对对象编程的三个基本概念**：数据抽象（类）、继承和动态绑定，**关键思想**：多态性

**封装，继承，多态**

封装和继承实现了代码重用，多态实现了接口重用。

[C++封装、多态、继承](https://blog.csdn.net/ruyue_ruyue/article/details/8211809?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.nonecase)

### 7.1 继承

- 派生类能继承基类定义的成员 
- 派生类可以无须改变而是用与派生类型具体特性不相关的操作
- 派生类可以重定义与派生类相关的成员函数
- 派生类除了从基类继承的成员还可定义更多的成员

**protected**：`protected`成员允许派生类访问但禁止该类型的普通用户访问

- `protected`成员不能被类的用户访问
- `protected`成员可被该类的派生类访问
- 派生类只能通过派生类对象访问基类的`protected`成员

**派生类**：

```c++
// access-specifier 是 public、private、protected
// base-class 是基类，derived-class 是派生类
class derived-class: access-specifier base-class{};
```

- 每个派生类对象包含两部分：从基类继承的成员和自己定义的成员
- 派生类可以访问基类的`public`和`protected`成员
- 可在运行时确定`virtual`函数的调用

**公用、私有和受保护的继承c**

派生类不能访问基类的`private`成员，也不能使自己的用户能够访问那些成员

- 如果是**公用继承**：基类的`public`成员为派生类的`public`成员，基类的`protected`成员为派生类的`protected`成员
- 如果是**受保护继承**：基类的`public`和`protected`成员在派生类中为`protected`成员
- 如果是**私有继承**：基类的所有成员为派生类的`private`成员

**友元函数不能被继承，构造函数，析构函数和拷贝构造函数不能被继承，重载运算符不能被继承**

**多继承**：

```c++
class <派生类名>：<继承方式1><基类名1>，<继承方式2><基类名2>,...
{

}
```



### 7.2 多态

当类之间存在层次结构，并且类之间是通过**继承**关联时，就会用到多态

**实现原理**：一种接口，多个方法，用**父类对象指针来访问子对象，然后根据子对象的函数来调用**。

>- 对象的静态类型：对象在声明时采用的类型，编译期确定的
>
>- 对象的动态类型：目前所指对象的类型，运行期决定的
>
>**对象的动态类型可以更改，静态类型无法更改**
>
>- 静态绑定：编译时绑定，绑定的是对象的静态类型，通过对象调用
>
>- 动态绑定：运行时绑定，绑定的是对象的动态类型，通过地址实现
>
>**在继承体系中只有虚函数使用的是动态绑定，其他的全部是静态绑定**
>
>- 静态多态：编译时多态性，通过重载函数实现，早绑定，在编译时确定函数地址
>- 动态多态：运行时多态性，通过虚函数实现，晚绑定，在运行时通过虚函数表查找函数地址

**虚函数**：在基类中使用关键字`virtual`声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数，而是根据所调用的对象类型来选择调用的函数。**虚函数必须实现**。

**纯虚函数**

去掉函数声明（定义）时候的{}，加上 `= 0`，就变成纯虚函数。**纯虚函数一定没有定义**。

```c++
class Shape{
public:
	virtual int area();	// 虚函数
    virtual int area() = 0; 	// 纯虚函数
}
```

- 包含纯虚函数的类是抽象类，抽象类不能实例化，但可以声明指向该抽象类的具体类的指针或引用
- 虚函数必须实现，父类和子类都有各自的版本，由多态方式调用的时候动态绑定
- 在动态分配堆上内存的时候，析构函数建议声明为虚函数，构造函数不能是虚函数
- **友元函数不能是虚函数**，**析构函数应该是虚函数，将调用相应对象类型的析构函数**
- 友元函数、全局函数、静态成员函数、构造函数不能是虚函数
- 关键字`virtual`只出现在类内部，不出现在类外部的定义中

**虚函数表**：编译器对每个包含虚函数的类创建一个虚函数表VTABLE，表中每一项指向一个虚函数的地址，即VTABLE表可以看成一个函数指针的数组，每个虚函数的入口地址就是这个数组的一个元素。

子类的虚函数表继承来自父类，若重载了父类的某一个虚函数，则虚函数表中对应项指向重载后的虚函数，否则不变。

在创建含有虚函数的类的对象的时候，编译器会在每个对象的内存布局中增加一个 vptr 指针项，该指针指向本类的 VTABLE。再通过指向基类对象的指针调用一个虚函数时，先获取所指对象的 vptr 指针，然后调用 vptr 所指向类的VTABLE中的对应项（具体虚函数的入口地址）。

- 类的对象都有一个指向虚函数表开始的虚指针
- 虚函数表是一个存储类成员函数指针的数据结构
- 当有虚函数时，每个对象都有一个指向虚函数的指针，作为类对象的第一个成员

**形成多态需具备的条件**：

1. 必须具备继承关系
2. 继承关系必须有同名虚函数
3. 存在基类类型的指针或引用，通过该指针或引用调用虚函数

### 7.3 数据封装

**数据抽象**是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。

数据抽象是一种依赖于接口和实现分离的编程（设计）技术。

所有的 C++ 程序都有以下两个基本要素：

- **程序语句（代码）：**这是程序中执行动作的部分，它们被称为函数。
- **程序数据：**数据是程序的信息，会受到程序函数的影响

**数据封装**是一种把数据和操作数据的函数捆绑在一起的机制，**数据抽象**是一种仅向用户暴露接口而把具体的实现细节隐藏起来的机制。

C++ 通过创建**类**来支持封装和数据隐藏。

封装可以隐藏实现细节，使得代码模块化；封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面；把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。

**C++接口（抽象类）**：接口描述了类的行为和功能，不需要完成类的特定实现；C++接口是使用抽象类来实现的，给其他类提供一个可以继承的适当的基类。抽象类不能实例化对象，可用于实例化对象的类称为具体类。

## 八 模板和泛型编程

泛型编程：以独立于任何特定类型的方式编写代码，模板是泛型编程的基础

模板是创建泛型类或函数的蓝图或公式

### 8.1 函数模板

- 函数模板是一个独立于类型的函数，可作为一种方式，产生函数的特定类型版本。

- 模板定义以关键字**`template`**开始，后接**模板形参表**，模板形参表是用尖括号括住的一个或多个模板形参的列表，形参之间以逗号分开，模板形参表不能为空

**函数模板的一般形式**：

```c++
template <class T> 返回类型 函数名(参数列表)
{
	/* 函数主体 */
}
```

**函数模板实例化：根据实际的模板实参绑定到模板形参，确定用什么类型代替每个类型形参,不用显式提供实参**

```c++
/* 声明一个函数模板，inline放在模板形参表之后 */
template <class T> inline T min(cnost T&, const T&){...};
/* 用函数模板实例化 */
a = min(1, 2); 
// T 是函数所使用的数据类型的占位符名称，可在函数主体定义中使用
```

### 8.2 类模板

- 类模板以关键字`template`开始，后接一个模板形参表，然后是类主体，可定义数据成员，函数成员，类型成员等操作
- 在类和类成员的定义中，可以使用模板形参作为类型或值的占位符，在使用类时在提供那些类型或值
- 模板形参可以是类型形参，也可以是非类型形参，是类型形参就表示未知类型，是非类型形参表示未知值
- 全局作用域中声明的对象、函数或类型同名的模板形参会屏蔽全局名字
- 用作模板形参的名字不能在模板内部重用
- 模板类型形参前面必须带上关键字`class`或`typename`，非类型形参必须带上类型名字

**类模板一般形式**

```c++
template<class T> class 类名
{
/* 与类的定义相同 */
public:
	T compare();
private:
	T m_iA;
}
```

**在使用类模板时，必须为模板形参显式指定实参**

```c++
template<calss T> class Queue{};
/* 调用类模板 */
Queue<int> que;
Queue<string> que1;
// 显式提供int string 实参，编译器使用实参来实例化这个类的特定类型版本
```

>**关于undefined reference to——C++模板类文件组织方式**
>
>g++编译器不支持模板类的分离编译，非专用模板的实现必须对使用它的翻译单元可见。编译器必须能够查看实现，以便为代码中的所有特化生成代码
>
>**解决办法**
>
>注：`queue.h`中定义模板类，`queue.cpp`对模板类进行实现
>
>1. 在`main.cpp`中`#include "queue.cpp"`，而非`"queue.h"`，这种方式就如同将队列类的声明实现放在同一文件中
>2. 在`queue.h`中，代码部分结尾处`#include "queue.cpp"`，并且去掉`queue.cpp`里的包含语句，这与上述方式如出一辄，只是在`main.cpp`中看上去就像习惯中的方案一样。
>3. 直接将实现写入`queue.h`中
>4. 声明类时，在类名前加上export关键字，但如今的c++编译器中这关键字多半行不通。就像foreach之类的关键字一样，多半会被认为是关键字，但是却是编译器不认识的。
>5.  main.cpp 文件中需要同时包含 .h 文件和 .cpp 文件，不然会出现链接错误

### 8.3 模板形参表

- 模板形参表是用尖括号括住的一个或多个模板形参的列表，形参之间以逗号分开，模板形参表不能为空
- 模板形参表示可以在类或函数的定义中使用的类型或值，以关键字**`class`**或**`typename`**开始
- 模板形参可以是表示类型的类型形参，也可以是表示常量表达式的非类型形参。

>**模板类型形参**
>
>- 由关键字`class`或`typename`后接说明符构成，在模板形参中这两个关键字相同
>- 作为说明符出现在模板的任何地方，与内置类型说明符或类类型说明符的使用方式相同
>
>**非类型形参**
>
>- 调用函数时，非类型形参用值代替，值的类型在模板形参中指定
>- 模板非类型形参是模板定义内部的常量值
>- 非类型模板实参必须是编译时常量表达式。

**`typename`和`class`的区别**

- 在模板形参表中，关键字`typename`和`class`有相同含义

- 在类定义中也是用`class`关键字，可能带来混淆，所以引入`typename`这个关键字

- `typename`另一个作用：使用嵌套依赖类型（在模板定义内部指定类型）

  ```c++
  class MyArray 
  { 
      public：
      typedef int LengthType;
  .....
  }
  
  template<class T>
  void MyMethod( T myarr ) 
  { 
      typedef typename T::LengthType LengthType; 
      LengthType length = myarr.GetLength; 
  }
  // 这里typename的作用就是说名typename后面的字符串为一个类型名称，而不是成员函数或者成员变量
  // 如果在模板内部使用在类中定义的类型成员，必须在该成员名前加上关键字typename，告知编译器将成员当做类型
  ```

### 8.4 实例化

- 产生模板的特定类型实例的过程称为实例化

- 类模板在引用实际模板类类型时实例化，函数模板在调用它或用它对函数指针进行初始化或赋值时实例化。

**类模板的实例化**

```c++
Queue<int> q;
```

- **类模板形参是必须的，使用类模板就必须显式地执行模板实参**

**函数模板的实例化**

```c++
compare(1,2);	/* 将函数模板实参绑定到 int 类型
```

- **使用函数模板时，编译器会会自动从实参的类型推断形参的类型**

- 多个类型形参的实参必须完全匹配

- 类型的实参的受限转化

  >一般而言，不会转化实参已匹配已有的实例化，相反会产生新的实例
  >
  >- `const `转换： 接受 `const` 引用或` const `指针的函数可以分别用非` const`对象的引用或指针来调用，无须产生新的实例化。
  >- 数组或函数到指针的转换：如果模板形参不是引用类型，则对数组或函数类型的实参应用常规指针转换。

- 可以用函数模板对函数指针进行初始化或赋值

  ```c++
  template <typename T> int compare(const T&, const T&);
  // pf1 points to the instantiation int compare (const int&, constint&)
  int (*pf1) (const int&, const int&) = compare;
  
  // pf1 的类型是一个指针，指向“接受两个 const int& 类型形参并返回 int值的函数”， 形参的类型决定了 T 的模板实参的类型， T 的模板实参为 int 型，指针 pf1 引用的是将 T 绑定到 int 的实例化。
  ```

- 当函数的返回类型必须与形参表中所用的所有类型都不同时，必须引入第三方函数模板形参，并且显式地指定形参类型

### 8.5 类模板成员

通常使用类模板的名字的时候必须执行模板形参，但是在类本身的作用域内部，可以使用类模板的非限定名

```c++
// 构造函数
Queue(const Queue &Q):head(0),tail(0){}
等价于：Queue<T>(const Queue<T> &Q):head(0),tail(0){}
```

**类模板成员函数**

定义具有如下形式：

- 必须以关键字 template 开关，后接类的模板形参表。
- 必须指出它是哪个类的成员。
- 类名必须包含其模板形参。

在类外定义的类模板的成员函数：

`template <class T> 返回类型 所属类名<T>::函数名(形参列表)/成员名`

```c++
/* 类模板 */
template <class T> calss Queue{
public:
	void destroy();
	void push(const T &val);
};
/* 类外定义 destroy 函数 */
template <class T> void Queue<T>::destroyy(){
	/* 操作 */
}
template <class T> void Queue<T>::push(const T &val)
{
	/* 操作 */
}
```

**类模板成员函数的实例化**

类模板的成员函数本身也是函数模板，类模板成员函数的模板形参由调用该函数的对象类型确定

`void Queue<int>::push(const int &val)`

### 8.6 重载与函数模板

函数模板可以重载：可以定义有相同名字但形参数目或类型不同的多个函数模板，也可以定义与函数模板有相同名字的普通非模板函数

重载的函数模板可能会导致二义性

**确定函数调用的步骤**

1. 为这个函数名建立候选函数集合，包括：
- 与被调用函数名字相同的任意普通函数。
- 任意函数模板实例化，在其中，模板实参推断发现了与调用中所用函数实参相匹配的模板实参。
2. 确定哪些普通函数是可行的（如果有可行函数的话）。候选集合中的每个模板实例都可行的，因为模板实参推断保证函数可以被调用。
3. 如果需要转换来进行调用，根据转换的种类排列可靠函数，记住，调用模板函数实例所允许的转换是有限的。
- 如果只有一个函数可选，就调用这个函数。
-  如果调用有二义性，从可行函数集合中去掉所有函数模板实例。
4. 重新排列去掉函数模板实例的可行函数。
- 如果只有一个函数可选，就调用这个函数。
- 否则，调用有二义性。

## 九 高级教程

### 9.1 异常处理

C++异常处理设计到三个关键字：`try、catch、throw`

- `throw`：当问题出现时，程序会抛出一个异常，`throw`关键字抛出异常
- `catch`：在想要处理问题的地方，通过异常处理程序捕获异常，`catch`关键字用于捕获异常
- `try`：`try`块中的代码标识将被激活的特定异常，后面常跟着一个或多个`catch`块

```c++
try
{
    //可能抛出异常的语句
}
catch (异常类型1)
{
    //异常类型1的处理程序
}
catch (异常类型2)
{
    //异常类型2的处理程序
}
// ……
catch (异常类型n)
{
    //异常类型n的处理程序
}
```

**抛出异常**：使用`throw`可在任何地方抛出异常，`throw`语句的操作数可以使任意的表达式，表达式的结果的类型决定了跑出的异常的类型

**捕获异常**：`catch`块跟在`try`块就免，用于捕获异常，由`catch`关键字后的括号内的异常声明决定要捕获的异常类型

**定义新的异常**：可以通过继承和重载`exception`类来定义新的异常

### 9.2 动态内存

C++程序中的内存分为两个部分：

- 栈：在函数内部声明的所有变量都将占用栈内存
- 堆：这是程序中未使用的内存，在程序运行时可用于动态内存分配

**`new`和`delete`运算符**：申请内存和释放内存

```c++
/* 通用语法 */
new data-type;

double *pValue = new double;
delete pValue;

char *str = new char[10];
delete []str;
```

`data-type`可以使包括数组在内的任意内置的数据类型，也可以是包括类或结构体在内的用户自定义的任何数据类型。

建议检查`new`运算符是否返回空指针来判断是否成功分配内存

对比`malloc`函数，**`new`不仅分配内存，还创建了对象**

**`delete 与 delete[]`**的区别：

- `delete ptr`代表释放内存，且只用来释放`ptr`指向的内存
- `delete [] prt`用来释放`ptr`指向的内存，还逐一调用数组中每个对象的“析构函数”

### 9.3 命名空间

命名空间就是定义一个范围，区分不同库中相同名称的函数、类、变量等。

命名空间的定义使用关键字`namespace`，后跟命名空间的名称。

```c++
namespace namespace_name{
	/* 代码声明 */
}
```

为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称

```c++
namesapce_name::code;	// code 可以是变量或函数
```

**using指令**：使用`using namespace`指令，这样使用命名空间就可以不用在前面加上命名空间的名称，例如：

```c++
using namespace std;
```

**命名空间可以嵌套**：可以通过`::`运算符来访问嵌套的命名空间中的成员

### 9.4 多线程

多线程是多任务处理的一种特殊形式，多任务处理允许让电脑同事运行两个或以上的程序，两种类型的多任务处理：

- 基于线程：同一程序的片段的并发执行
- 基于进程：程序的并发执行，传统的进程有两个基本属性：可拥有资源的独立单位；可独立调度和分配的基本单位

多线程程序包含可以同时运行的两个或多个部分。这样的程序中的每个部分称为一个线程，每个线程定义了一个单独的执行路径。

**同一进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递**

**相关函数**：

- `get_id`：获取线程 id
- `join`：加入等待
- `detach`：分离线程
- `swap`：线程交换
- `hardware_concurrency`：检测硬件并发特性

**创建线程**：创建一个新的线程，并让它可执行`std::thread t(thread, ...)`

**终止线程**：用于显式地退出一个线程，通常在线程完成工作后无须继续存在时被调用

**连接和分离**：

创建一个线程时，某个属性会定义它是否是可连接的或可分离的，只有创建时定义为可连接的线程才能被连接。

C++ 标准库提供多线程库，使用时加头文件`#include <thread>`，该头文件主要包含对线程的管理类`std::thread`以及其他管理线程相关的类

多线程编程最核心的问题是资源竞争：CPU 由多核，但控制台只有一个，同时只能有一个线程拥有这个唯一的控制台。

**共享数据的管理和线程间的通信**是多线程编程的两大核心

当线程启动后，一定要在和线程相关联的`thread`销毁前，确定以何种方式等待线程执行结束，两种方式等待线程结束，

`detach`和`join`都是`thread`类的成员函数

- `detach`方式：启动的线程自主在后台运行，当前代码继续往下执行，不等待新线程结束
- `join`方式：等待启动的线程完成，才会继续往下执行

相应的详细介绍可查看：



[C++ 多线程编程]: https://blog.csdn.net/coolwriter/article/details/79883253?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2&amp;utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2

## 十 `STL` 标准模板库

### 10.1 C++ 容器

容器：存放数据的类模板，可变数组、二叉树、链表等**数据结构**在 `STL` 中被实现为容器

**顺序容器**：可变长动态数组`vector`、双端队列`deque`、双向链表`list`

​	元素在容器中的位置与元素的值无关

**关联容器**：`set`、`multiset`、`map`、`multimap`(排序容器)

C++11 规定：unordered_set、unordered_multiset、unordered_map、unordered_multimap（哈希容器）

- 排序容器：元素在容器中的位置是排序的
- 哈希容器：元素在容器的位置是由哈希函数确定的

只要两个容器对象的类型相同就可以用`<、<=、>、>=、==、!=`进行比较。

所有的容器都具有的成员函数：`int size(); bool empty();`

顺序容器和关联容器具有的成员函数：`begin(); end(); rbegin();rend();erase();clear()`

### 10.2 迭代器

要访问容器中的元素，除了下标操作之外，可以使用迭代器(iterator)进行，迭代器指向容器中的某个元素，通过迭代器就可以读写它指向的元素

迭代器定义方式如下：

```c++
容器类名：：iterator 迭代器名；		// 正向迭代器
容器类名：：reverse_iterator 迭代器名；	// 反向迭代器
```

**迭代器用法**：`迭代器名`就表示迭代器指向的元素

- 迭代器都可以进行 ++ 操作，对正向迭代器 ++ 操作时，指向后一个元素，对反向迭代器 ++ 操作时，指向前一个元素
- 如果迭代器指向容器最后一个元素的后一位置或第一个元素的前一位置，通过迭代器访问可能使程序崩溃

常用的迭代器按功能强弱分为输入、输出、正向、双向、随机访问 5 种。

- 正向迭代器只支持 `++`操作，不支持`--`操作
- 双向迭代器支持`++、--`操作
- 随机访问迭代器支持`--、++、p+i、p-i`等操作，两个随机访问迭代器可用`<,>,<=,>=`进行比较。

不同容器的迭代器功能：

| 容器            | 迭代器功能   |
| --------------- | ------------ |
| `vector`        | 随机访问     |
| `deque`         | 随机访问     |
| `list`          | 双向         |
| `set、multiset` | 双向         |
| `map、multimap` | 双向         |
| `stack`         | 不支持迭代器 |
| `queue`         | 不支持迭代器 |
| priority_queue  | 不支持迭代器 |

### 10.3 容器中常见的函数成员

| 函数成员       | 函数功能                                                     | array<T,N> | vector<T> | deque<T> |
| -------------- | ------------------------------------------------------------ | ---------- | --------- | -------- |
| begin()        | 返回指向容器中第一个元素的迭代器。                           | 是         | 是        | 是       |
| end()          | 返回指向容器最后一个元素所在位置后一个位置的迭代器，通常和 begin() 结合使用。 | 是         | 是        | 是       |
| rbegin()       | 返回指向最后一个元素的迭代器。                               | 是         | 是        | 是       |
| rend()         | 返回指向第一个元素所在位置前一个位置的迭代器。               | 是         | 是        | 是       |
| assign()       | 用新元素替换原有内容。                                       | -          | 是        | 是       |
| operator=()    | 复制同类型容器的元素，或者用初始化列表替换现有内容。         | 是         | 是        | 是       |
| size()         | 返回实际元素个数。                                           | 是         | 是        | 是       |
| max_size()     | 返回元素个数的最大值。这通常是一个很大的值，一般是 232-1，所以我们很少会用到这个函数。 | 是         | 是        | 是       |
| capacity()     | 返回当前容量。                                               | -          | 是        | -        |
| empty()        | 判断容器中是否有元素，若无元素，则返回 true；反之，返回 false。 | 是         | 是        | 是       |
| resize()       | 改变实际元素的个数。                                         | -          | 是        | 是       |
| front()        | 返回第一个元素的引用。                                       | 是         | 是        | 是       |
| back()         | 返回最后一个元素的引用。                                     | 是         | 是        | 是       |
| operator[]()   | 使用索引访问元素。                                           | 是         | 是        | 是       |
| at()           | 使用经过边界检査的索引访问元素。                             | 是         | 是        | 是       |
| push_back()    | 在序列的尾部添加一个元素。                                   | -          | 是        | 是       |
| insert()       | 在指定的位置插入一个或多个元素。                             | -          | 是        | 是       |
| emplace()      | 在指定的位置直接生成一个元素。                               | -          | 是        | 是       |
| emplace_back() | 在序列尾部生成一个元素。                                     | -          | 是        | 是       |
| pop_back()     | 移出序列尾部的元素。                                         | -          | 是        | 是       |
| erase()        | 移出一个元素或一段元素。                                     | -          | 是        | 是       |
| clear()        | 移出所有的元素，容器大小变为 0。                             | -          | 是        | 是       |
| swap()         | 交换两个容器的所有元素。                                     | 是         | 是        | 是       |

### 10.4 vector 容器

 vector 实现的是一个动态数组，即可以进行元素的插入和删除，在此过程中，vector 会动态调整所占用的内存空间，整个过程无需人工干预。

```c++
#include <vector>
using namespace std;

```

**创建 vector 的方式**

```c++
// 空容器，没有指定 std 命名空间，就加上 std::
vector<double> values;
// 创建的同时指定初始值和元素个数
vector<int> primes {2, 3, 5, 7, 11, 13, 17, 19};
// 指定元素个数，默认初始化，或者 vector<double> values(20, 2.0);
vector<double> values(20);	
// 通过存储类型相同的其他 vector 容器创建新的 vector 容器
std::vector<char>value1(5, 'c');
std::vector<char>value2(value1);

```

**成员函数**

```c++
begin()/end()
rbegin()/rend()
size()/resize()
capacity()/empty()
operator[]/at()
front()/back()
assign()/insert()
push_back()/pop_back()
clear()/erase()
swap()/emplace()
```

**迭代器使用**

vector 容器的迭代器是随机访问迭代器，`begin()/end()/rbegin()/rend()`等成员函数支持迭代器。

vector 容器在申请更多内存的同时，容器中的所有元素可能会被复制或移动到新的内存地址，这会导致之前创建的迭代器失效。

**访问元素方式**

```c++
[]
at()
front()
back()
size():访问多个元素
```

**size** 指容器当前拥有的元素个数；而 **capacity** 则指容器在必须分配新存储空间之前可以存储的元素总数

**添加元素**0-0-p0 

```c++
emplace_back() 和 push_back() 的区别，就在于底层实现的机制不同。
push_back() 向容器尾部添加元素时，首先会创建这个元素，然后再将这个元素拷贝或者移动到容器中（如果是拷贝的话，事后会自行销毁先前创建的这个元素）
emplace_back() 在实现时，则是直接在容器尾部创建这个元素，省去了拷贝或移动元素的过程。
```



### 10.3 关联容器

**pair类模板**：

类模板：template<class T1,class T2> struct pair

参数：T1是第一个值的数据类型，T2是第二个值的数据类型。

功能：pair将一对值(T1和T2)组合成一个值，

        这一对值可以具有不同的数据类型（T1和T2），
    	两个值可以分别用pair的两个公有函数first和second访问。



`multiset`：排好序的集合，允许有相同的元素，不能直接修改容器中的元素。

```shell
template <class Key, class Pred = less<Key>, class B = allocator<Key> > class multiset
{
...
};
# 第一个类型参数说明 multiset 容器中每个元素都是 Key 类型
# 第二个类型参数 Pred 用于指明容器中元素的排序顺序，可是函数对象类，也可以是函数指针类型
# 第三个参数一般使用默认值
typedef multiset <A> MSET1; /* MSET1 用 "<" 比较大小
typedef multiset <A, MyLess> <SET2;  /* MSET2 用MyLess::operator() 比较大小
```

`set`：关联容器，元素已经排好序，与`multiset`的差别在于`set`中不存在重复元素

`multimap`：容器中的元素分为关键字和值两部分，元素是按照关键字排序的，并且允许有多个相同元素，同时不允许修改容器中的关键字

```shell
template <class Key, class T, class Pred = less<Key>, class A = allocator<T> > 
class multimap
{
	...
	typedef pair <const Key, T> value_type;
	...
};
# 第一个类型参数说明值的类型，第二个类型参数说明关键字的类型
# multimap 中的元素是 pair 模板类的对象，元素的 first 成员变量叫关键字，second 成员变量叫值
# 容器中的元素按照关键字从小到大的顺序排序
# value_type 表示容器中元素的类型
# multimap 及 map 中的 find 和 count 不用==运算符比较两个关键字是否相等。如果x比y小和y比x小同时为假，就   认为 x 和 y 相等。
```

`map`：每个元素分为关键字和值两部分，容器中元素按照关键排序

### 10.4 容器适配器

`STL`中的容器适配器由`stack、queue，priority_queue`三种

容器适配器都有以下三个成员函数：

- `push`：添加一个元素
- `top`：返回顶部元素或者队头的引用
- `pop`：删除一个元素

容器适配器是没有迭代器的，`STL`中的排序、查找等算法不适用

**stack**：包含头文件<stack>

- 一种后进先出的元素序列，访问和删除都只能对栈顶元素进行操作，元素也只能被添加到栈顶

**queue**：包含头文件<queue>

- 一种先进先出的队列，访问和删除操作只在队头进行，添加操作只能在队尾进行

**priority_queue**：优先队列，队头元素中是最大的

- 队头元素只能被查看或者修改，不能被删除
- 采用堆排序技术实现，其内部不完全有序，总保证最大元素在队头





## 十一 结构体

### 11.1 结构体定义

结构体可以用来存放一组不同类型的数据，集合了多个变量或者数组，这样的变量或数组称为结构体的成员，定义形式如下：

```shell
struct structName
{
	// 结构体所包含的变量或数组
};

struct stu
{
	char *name;		// 姓名
	int num;		// 学号
	int age;		// 年龄
	char group;		// 所在小组
	float score;	// 成绩
}；

# 大括号后面的分号 ; 不能少，结构体这样的叫复杂数据类型/构造数据类型；int这样的叫基本数据类型
```

**结构体变量**

定义两个变量stu1，stu2：`struct stu stu1, stu2`

也可以在定义结构体的同时定义结构体变量：

```shell
struct stu
{
	// 变量或数组
}stu1，stu2;
```

- 通过`.`运算符来访问(获取和赋值)结构体成员：`结构体变量名.成员名`
- 结构体是一种自定义数据类型，创建变量的模板，不占用内存空间；结构体变量才包含数据，需要内存空间来存储

### 11.2 结构体使用

**结构体数组**：数组中每个元素都是一个结构体，结构体数组常用来表示一个拥有相同数据结构的群体

```shell
struct stu
{
	// 变量或数组
}class[5];
// 表示一个班级有 5 个学生
```

**结构体指针**：指向结构体的指针变量

```shell
struct 结构体名 *变量名;
struct stu *pStu = &stu1;
```

- 要想取得结构体变量的地址，必须在前面加`&`
- 使用 `->`来通过结构体指针访问结构体成员

**结构体枚举类型**：

```shell
enum typaName{valueName1, valueName2, valueName3, ...};
```

- 枚举值默认从 0 开始，往后逐个加 1，也可以自己指定值

### 11.3 联合体（union）

```shell
// union 定义格式
union 联合体名
{
	// 成员列表
}；
```

- 结构体的各个成员会占用不同的内存，相互之间没有影响；联合体的所有成员占用同一段内存，修改一个成员会影响到其余所有成员

### 11.4 C 中的补充

**typename**：使用关键字`typename`可以为类型起一个新的别名

```shell
typename oldName newName；
```

- `typename`可以为数组、指针、结构体等类型定义别名
- `typename`是一种彻底的“封装”类型，声明之后不能再往里面增加别的东西

**C文件操作**：

C 语言中硬件设备可以看成文件，操作文件的正常流程为：打开文件->读写文件->关闭文件

打开文件就是获取文件的相关信息，例如文件名、文件状态、当前读写位置等。这些信息会被保存到一个 
FILE 类型的结构体文件中。

数据在文件和内存之间传递的过程叫做文件流。

- 打开文件：`fopen`函数（`FILE *fopen(char *filename, char *mode);`）

- 关闭文件：`fclose`函数（`int fclose(FILE *fp);`)

- 字符读取：`fgetc`函数（`int fgetc(FILE *fp);`）

  文件内部有一个位置指针，指向当前读写到的位置

- 字符写入：`fputc`函数（`int fputc(int ch, FILE 8fp);`）

- 读字符串：`fgets`函数（`char *fgets(char *str, int n, FILE *fp);`）

  如果遇到换行或者到文件末尾则读取结束

- 写字符串：`fputs`函数（`int fputs(char *str, FILE *fp);`）

- 读数据块：`fread`函数（`size_t fread(void *ptr, size_t size, size_t count, FILE *fp);`）

- 写数据块：`fwrite`函数（`size_t fwrite(void *ptr, size_t size, size_t count, FILE *fp);`）

- 格式化读写文件

  ```shell
  int fscanf ( FILE *fp, char * format, ... );
  int fprintf ( FILE *fp, char * format, ... );
  ```

- 随机读写文件：关键是按照要求移动位置指针，这称为文件定位

  ```shell
  // 用来将位置指针移动到文件开头，前面已经多次使用过，它的原型为：
  void rewind ( FILE *fp );
  // 用来将位置指针移动到任意位置，一般用于二进制文件读写：
  int fseek ( FILE *fp, long offset, int origin );
  ```

  

## C++面试常见问题

### 1 static关键字的作用

- 全局静态变量：静态存储区，整个程序运行期间一直存在；在声明他的文件之外是不可见的
- 局部静态变量：静态存储区，当定义它的函数或者语句块结束，作用域结束；；但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存当中，只不过我们不能再对它进行访问，直到该函数再次被调用，并且值不变
- 静态函数：只在声明静态函数的文件当中可见，但其他文件不可见
- 类的静态成员：静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用
- 类的静态函数：类的静态成员，不是对象成员；在静态成员函数的实现中不能直接引用类中的非静态成员，可以引用类中说明的静态成员

### C 和 C++ 的区别

- C++面对对象，C语言面向过程
- C++由封装、继承、多态额特性
- C++支持范式编程，比如类模板、函数模板
- 动态内存分配，C++包含C的malloc和free，并且具有new和delete

### C++ 的智能指针

智能指针的作用是管理一个指针，智能指针是一个类，当超出类的作用域的时候，类会自动调用析构函数来释放资源，即在函数结束时自动释放内存空间

- auto_ptr：采用所有权模式                                

	```c++
	auto_ptr< string> p1 (new string ("I reigned lonely as a cloud.”));
	auto_ptr<string> p2;
	p2 = p1; //auto_ptr不会报错.
	// 此时不会报错，p2剥夺了p1的所有权，但是当程序运行时访问p1将会报错。所以auto_ptr的缺点是：存在潜在的内存崩溃问题！
	```

- unique_ptr：实现独占式拥有或严格拥有概念，保证同一时间内只有一个智能指针可以指向该对象。它对于避免资源泄露(例如“以new创建对象后因为发生异常而忘记调用delete”)特别有用

    ```c++
    unique_ptr<string> p3 (new string ("auto"));   //#4
    unique_ptr<string> p4；                       //#5
    p4 = p3;//此时会报错！！
    ```

- shared_ptr：实现共享式拥有概念。多个智能指针可以指向相同对象，该对象和其相关资源会在“最后一个引用被销毁”时候释放。从名字share就可以看出了资源可以被多个指针共享，它使用计数机制来表明资源被几个指针共享

- weak_ptr：一种不控制对象生命周期的智能指针, 它指向一个 shared_ptr 管理的对象. 进行该对象的内存管理的是那个强引用的 shared_ptr. weak_ptr只是提供了对管理对象的一个访问手段；辅助shared_ptr工作，避免两个shared_ptr指针互指造成的死锁问题

### C++的四种cast转换

- const_cast：将const变量转换为非const
- static_cast：各种隐式转换，非cosnt转const，void*转指针等
- dynamic_cast：动态类型转换，只能用于含虚函数的类；智能转指针和引用
- reinterpret_cast：几乎什么都可以转，比如int转指针，但可能会出问题

### C/C++中指针和引用的区别

- 指针是一个变量/对象，有自己的内存空间；引用只是一个别名
- sizeof一个指针的大小是 4，而sizeof引用则是被引用对象的大小
- 指针可以被初始化为NULL，而引用必须被初始化并且是一个已有对象的引用
- 指针在使用的时候可以指向其他对象，但引用只能指向一个对象，不能被改变
- 指针有多级，但引用只有一级

### 

